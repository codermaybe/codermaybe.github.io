# 计算方式优化

[opcodes 消耗量](https://www.evm.codes/)

## 乘除法优化

### 乘法优化

```solidity
// 不推荐
a = a * 2;    // mul: 5 gas

// 推荐
a = a << 1;   // shl: 3 gas
```

### 除法优化

```solidity
// 不推荐
a = a / 2;    // div: 5 gas

// 推荐
a = a >> 1;   // shr: 3 gas
```

### 常见优化倍数

```solidity
// 乘以 2
x * 2  ->  x << 1

// 乘以 4
x * 4  ->  x << 2

// 乘以 8
x * 8  ->  x << 3

```

位运算能够优化的范围较小,为 2 的倍数，当 a = a \* 3(mul :5) 出现时不建议拆分为 a = a + a<<1 (消耗 shl :3 + add: 3)

## 预计算

### 常量计算

```solidity
// 不推荐
uint256 constant = 2**256 - 1;  // 每次调用都计算

// 推荐
uint256 constant = type(uint256).max;  // 编译时计算
```

### 循环优化

```solidity
// 不推荐
for(uint i = 0; i < array.length; i++) {
    // 每次循环都计算 array.length
}

// 推荐
uint length = array.length;
for(uint i = 0; i < length; i++) {
    // 只计算一次长度
}
```

## 数学函数优化

### 取整优化

```solidity
// 不推荐
uint256 result = (a + b) / 2;  // 先加后除

// 推荐
uint256 result = a + (b - a) / 2;  // 避免中间结果溢出
```

### 比较优化

```solidity
// 不推荐
if (a * b > c)  // 先乘后比较

// 推荐
if (a > c / b)  // 先除后比较，避免乘法溢出
```

## Gas 消耗参考

| 操作 | Gas 消耗 | 说明     |
| ---- | -------- | -------- |
| ADD  | 3        | 加法     |
| MUL  | 5        | 乘法     |
| DIV  | 5        | 除法     |
| SHL  | 3        | 左移     |
| SHR  | 3        | 右移     |
| AND  | 3        | 与运算   |
| OR   | 3        | 或运算   |
| XOR  | 3        | 异或运算 |
| NOT  | 3        | 非运算   |

## 最佳实践

1. **使用位移代替乘除**

   - 对于 2 的幂次方运算，使用位移操作
   - 位移操作比乘除法更省 gas

2. **避免重复计算**

   - 将循环中不变的值提取出来
   - 使用常量存储固定值

3. **注意数值范围**

   - 避免中间结果溢出
   - 合理使用数学运算顺序

4. **使用内置函数**
   - 优先使用 Solidity 内置的数学函数
   - 避免自己实现复杂的数学运算

## 注意事项

1. **精度损失**

   - 位移操作可能导致精度损失
   - 需要根据业务需求选择合适的运算方式

2. **可读性**

   - 在追求 gas 优化的同时保持代码可读性
   - 添加适当的注释说明优化原因

3. **测试验证**
   - 优化后进行充分测试
   - 确保优化后的结果与原来一致
