<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/codermaybe" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="免责声明"><a class="header" href="#免责声明">免责声明</a></h1>
<p>本站为<a href="index.html"><strong>个人博客</strong></a>，分享记录个人学习过程和相关信息。所有内容如有外部来源，将会在分享时明确标注，如有遗漏，请通过<a href="mailto://web3test1@outlook.com">邮件</a>联系以便及时删除。未标注来源的部分（如代码等），读者可以自由使用，但需自行承担使用可能带来的后果。关于信息的准确性请读者自行鉴别，这不是科普，绝大多数情况下无法做到精准描述。</p>
<h1 id="关于个人"><a class="header" href="#关于个人">关于个人</a></h1>
<p>我是 <strong>徐</strong> ，此博客旨在分享技术学习和个人见解。欢迎查阅我的简历，部分信息<a href="./Personal/%E7%AE%80%E5%8E%86.html">在此</a>。</p>
<p>希望能找到一个对于区块链行业有热忱的团队一起奋进。如果我的技术栈刚好符合你的需求，可以通过<a href="mailto://web3test1@outlook.com">邮件</a>与我进一步联系。部分技术栈不匹配的问题也可以后续跟进。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源导航"><a class="header" href="#资源导航">资源导航</a></h1>
<blockquote>
<p>遇到收费等情况自行斟酌，仅做推荐</p>
</blockquote>
<h2 id="电子书站点"><a class="header" href="#电子书站点">电子书站点</a></h2>
<p><a href="https://annas-archive.org/">安娜的档案</a></p>
<p><a href="https://libgen.li/">创世纪</a></p>
<p><a href="https://z-lib.id/">zlibrary</a></p>
<p><a href="https://xmsoushu.com/#/">熊猫搜索</a></p>
<p><a href="http://www.ucdrs.superlib.net/">全国图书馆参考咨询联盟</a> -&gt;声名不显的网站，在国内流通的任何书籍无论冷门热门均有，包括冷门教材。获取书籍方法需要渠道，可淘宝问。</p>
<h2 id="文献"><a class="header" href="#文献">文献</a></h2>
<p><a href="https://www.sci-hub.se/">sci-hub</a></p>
<p><a href="https://scholar.google.com/">谷歌学术搜索</a></p>
<h2 id="娱乐影视"><a class="header" href="#娱乐影视">娱乐影视</a></h2>
<p><a href="https://yinghezhinan.com/">硬核指南</a></p>
<p><a href="https://ddys.pro/">低端影视</a></p>
<p><a href="https://www.nfyingshi.com/">奈菲影视</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联系方式"><a class="header" href="#联系方式">联系方式</a></h1>
<ul>
<li>
<p>简要:因为个人隐私原因不在网络公示个人信息，可通过邮件联系</p>
</li>
<li>
<p><strong>Email</strong>：web3test1@outlook.com</p>
</li>
<li>
<p><strong>Github</strong>：<a href="https://github.com/codermaybe">https://github.com/codermaybe</a></p>
</li>
</ul>
<hr />
<h2 id="个人信息"><a class="header" href="#个人信息">个人信息</a></h2>
<ul>
<li><strong>姓名</strong>：徐</li>
<li><strong>性别</strong>：男</li>
<li><strong>出生年份</strong>：2000</li>
<li><strong>学历</strong>：本科 / xxx计算机系网络工程专业</li>
<li><strong>工作年限</strong>：2年</li>
<li><strong>期望职位</strong>：区块链开发</li>
<li><strong>期望薪资</strong>：9-12K</li>
<li><strong>期望城市</strong>：深圳 / 远程</li>
</ul>
<hr />
<h2 id="工作经历"><a class="header" href="#工作经历">工作经历</a></h2>
<h3 id="xxx--网络工程师"><a class="header" href="#xxx--网络工程师"><strong>xxx</strong> | <strong>网络工程师</strong></a></h3>
<p><strong>2023年6月 ~ 至今</strong></p>
<ul>
<li>主导网络架构设计与实施，熟悉Panabit、爱快、高恪、ROS、OpenWrt等软路由系统，具备丰富的实操经验。</li>
<li>完成网络布线规划及设备选型，采用<strong>ikuai软路由+华为S5700-24TP-SI-AC</strong>方案，配置ACL、VLAN、IPSec VPN、行为管理及DPI检测分流，支持200个房间近300人同时在线，网络稳定运行近两年。</li>
<li>负责日常网络维护与优化，确保高并发场景下的流畅体验。</li>
</ul>
<h3 id="xxx--网络运维工程师"><a class="header" href="#xxx--网络运维工程师"><strong>xxx</strong> | <strong>网络运维工程师</strong></a></h3>
<p><strong>2023年2月 ~ 2023年5月</strong></p>
<ul>
<li>日均处理20+家企业网络问题，服务规模涵盖20-500人，独立完成路由器选型、配置及VPN（IPSec/L2TP/PPTP）部署，实现跨平台、跨厂家设备互联互通。</li>
<li>熟练配置企业级交换机，支持大流量数据交互，具备华为、深信服、锐捷等主流网络设备的调试与故障排查能力。</li>
<li>解决多起防火墙配置问题，提升企业网络安全性及稳定性。</li>
</ul>
<hr />
<h2 id="技能清单"><a class="header" href="#技能清单">技能清单</a></h2>
<h3 id="技术栈"><a class="header" href="#技术栈"><strong>技术栈</strong></a></h3>
<ul>
<li><strong>编程语言</strong>：Java / Rust / Solidity</li>
<li><strong>Web3开发框架及工具</strong>：
<ul>
<li>交互：Ethers.JS（主） / Web3.JS</li>
<li>前端基础开发：ReactJS / Web3uikit / Antd / Wagmi / HTML / JS / TS / CSS / AJAX</li>
<li>智能合约开发与部署：Solidity / Rust / Hardhat（含Hardhat Ignition、Hardhat Truffle等） / Ganache</li>
<li>合约检查工具：Slither</li>
</ul>
</li>
<li><strong>数据库</strong>：MySQL</li>
<li><strong>版本管理与部署工具</strong>：Git</li>
</ul>
<h3 id="区块链能力"><a class="header" href="#区块链能力"><strong>区块链能力</strong></a></h3>
<ol>
<li>
<p><strong>智能合约开发</strong>：</p>
<ul>
<li>熟悉ERC-20、ERC-721、ERC-777、ERC-1155、ERC-4626等标准，具备独立开发、部署和上线智能合约的经验。主要实践项目部署于以太坊测试链。</li>
<li>熟练使用OpenZeppelin安全合约库,如RBAC,Ownable2等实用功能，阅读过Uniswap、USDT等项目的源码，了解UTXO与账户余额存储机制的区别。</li>
</ul>
</li>
<li>
<p><strong>区块链生态理解</strong>：</p>
<ul>
<li>了解DeFi、GameFi、DApp等方向，实现过简单的ERC-20流动池货币兑换项目。</li>
<li>熟悉Uniswap、Layer2、IPFS等技术实现，了解RWA、AMM、永续合约等概念及实现方式。</li>
</ul>
</li>
<li>
<p><strong>共识机制</strong>：</p>
<ul>
<li>熟悉PoW、PoS、DPOS、PoH、PBFT等共识机制的原理及应用场景。</li>
</ul>
</li>
</ol>
<h3 id="计算机基础"><a class="header" href="#计算机基础"><strong>计算机基础</strong></a></h3>
<ul>
<li><strong>英语能力</strong>：英语六级，能流畅阅读并理解英文技术文档。</li>
<li><strong>计算机组成</strong>：
<ul>
<li>熟悉CPU流水线、访存、译码、写回等阶段，了解进制转换、有符号数/无符号数计算、溢出等概念。</li>
<li>掌握汇编语言、机器指令实现方式及编译过程，熟悉计算机存储层次结构。</li>
</ul>
</li>
<li><strong>计算机网络</strong>：
<ul>
<li>熟悉OSI七层模型和TCP/IP模型，了解TCP协议、HTTP协议及Socket编程。</li>
<li>具备路由器、交换机、防火墙、AC+AP等网络设备的实操经验。</li>
</ul>
</li>
<li><strong>Rust语言</strong>：
<ul>
<li>熟悉所有权系统、借用与生命周期、数据类型、函数与闭包、错误处理等核心特性。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h2>
<h3 id="区块链交互工具"><a class="header" href="#区块链交互工具"><strong>区块链交互工具</strong></a></h3>
<ul>
<li><strong>项目链接</strong>：<a href="https://github.com/codermaybe/BlockChain_InteractTools">https://github.com/codermaybe/BlockChain_InteractTools</a></li>
<li><strong>功能</strong>：
<ul>
<li>以太坊余额查询、通用合约交互(目前仅view/pure方法可调用)。</li>
<li>随机钱包申请、转账、钱包恢复(助记词)、remix合约部署重定向。</li>
<li>区块链历史交易查询、区块链合约事件监听、代币归集等功能。</li>
<li>预计引入私钥管理，支持私钥导入、导出、管理。向完善的去中心化钱包发展。</li>
</ul>
</li>
</ul>
<h3 id="区块链投票系统"><a class="header" href="#区块链投票系统"><strong>区块链投票系统</strong></a></h3>
<ul>
<li><strong>项目链接</strong>：<a href="https://github.com/codermaybe/VotingSystem">https://github.com/codermaybe/VotingSystem</a></li>
<li>V1.0版本：
<ul>
<li>单项目投票、管理员开奖，投票结果查询。</li>
</ul>
</li>
<li>V2.0版本：
<ul>
<li>多项目同时投票、用户发起项目权限控制、定时开奖、投票结果查询、略微复杂的设计模式。</li>
</ul>
</li>
</ul>
<h3 id="solidity智能合约开发"><a class="header" href="#solidity智能合约开发"><strong>Solidity智能合约开发</strong></a></h3>
<ul>
<li><strong>项目链接</strong>：<a href="https://sepolia.etherscan.io/address/0x48aeCf60f7D272Dc118409CE5FB589386d4267eE">https://sepolia.etherscan.io/address/0x48aeCf60f7D272Dc118409CE5FB589386d4267eE</a></li>
<li><strong>描述</strong>：包含多个智能合约的部署与调用记录，展示实际开发能力。</li>
</ul>
<h3 id="rust子网转换工具"><a class="header" href="#rust子网转换工具"><strong>Rust子网转换工具</strong></a></h3>
<ul>
<li><strong>项目链接</strong>：<a href="https://github.com/codermaybe/IP_SubnetConverter_Flawed">https://github.com/codermaybe/IP_SubnetConverter_Flawed</a></li>
<li><strong>功能</strong>：将Windows默认输出文本转换为路由条目，展示Rust编程能力。</li>
</ul>
<h3 id="毕业设计p2p局域网聊天工具"><a class="header" href="#毕业设计p2p局域网聊天工具"><strong>毕业设计：P2P局域网聊天工具</strong></a></h3>
<ul>
<li><strong>项目链接</strong>：<a href="https://github.com/codermaybe/display">https://github.com/codermaybe/display</a></li>
<li><strong>功能</strong>：支持大文件互传和实时信息传输，展示网络编程能力。</li>
</ul>
<hr />
<h2 id="致谢"><a class="header" href="#致谢">致谢</a></h2>
<p>感谢您花时间阅读我的简历，期待能有机会和您共事！</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>XU</strong><br />
<em>(Blockchain Developer Candidate)</em></p>
<hr />
<h3 id="contact"><a class="header" href="#contact"><strong>Contact</strong></a></h3>
<ul>
<li><strong>Email</strong>: web3test1@outlook.com</li>
<li><strong>GitHub</strong>: <a href="https://github.com/codermaybe">codermaybe</a></li>
</ul>
<hr />
<h3 id="basic-information"><a class="header" href="#basic-information"><strong>Basic Information</strong></a></h3>
<ul>
<li><strong>Gender</strong>: Male</li>
<li><strong>Year of Birth</strong>: 2000</li>
<li><strong>Education</strong>: Bachelor's Degree in Network Engineering (Computer Science)</li>
<li><strong>Work Experience</strong>: 2 years</li>
<li><strong>Target Position</strong>: Blockchain Developer</li>
<li><strong>Salary Expectation</strong>: 9-12K RMB/month</li>
<li><strong>Preferred Location</strong>: Shenzhen / Remote</li>
</ul>
<hr />
<h3 id="work-experience"><a class="header" href="#work-experience"><strong>Work Experience</strong></a></h3>
<h4 id="xxx-company--network-engineer"><a class="header" href="#xxx-company--network-engineer"><strong>xxx Company | Network Engineer</strong></a></h4>
<p><em>(June 2023 - Present)</em></p>
<ul>
<li>Led network architecture design and implementation using Panabit/iKuai/OpenWrt systems</li>
<li>Deployed network infrastructure for 200 rooms (300+ users) with iKuai router + Huawei S5700-24TP-SI-AC</li>
<li>Configured ACL/VLAN/IPSec VPN/behavior management/DPI traffic shaping</li>
<li>Maintained 99% network uptime for 2 years</li>
</ul>
<h4 id="xxx-company--network-operations-engineer"><a class="header" href="#xxx-company--network-operations-engineer"><strong>xxx Company | Network Operations Engineer</strong></a></h4>
<p><em>(February 2023 - May 2023)</em></p>
<ul>
<li>Resolved 20+ enterprise network issues daily (20-500 user scale)</li>
<li>Deployed cross-vendor VPN solutions (IPSec/L2TP/PPTP)</li>
<li>Configured enterprise switches (Huawei/Sangfor/Ruijie)</li>
</ul>
<hr />
<h3 id="technical-skills"><a class="header" href="#technical-skills"><strong>Technical Skills</strong></a></h3>
<h4 id="core-technical-stack"><a class="header" href="#core-technical-stack"><strong>Core Technical Stack</strong></a></h4>
<ul>
<li><strong>Languages</strong>: Java/Rust/Solidity</li>
<li><strong>Web3 Tools</strong>:
<ul>
<li>Frontend: ReactJS/Web3uikit/Antd/Wagmi/TS</li>
<li>Smart Contracts: Hardhat/Ganache/Slither</li>
<li>Libraries: Ethers.js (Primary)/Web3.js</li>
</ul>
</li>
</ul>
<h4 id="blockchain-expertise"><a class="header" href="#blockchain-expertise"><strong>Blockchain Expertise</strong></a></h4>
<ol>
<li>
<p><strong>Smart Contracts</strong>:</p>
<ul>
<li>ERC-20/721/777/1155/4626 implementation</li>
<li>OpenZeppelin (RBAC/Ownable2) integration</li>
<li>Uniswap/USDT code analysis</li>
</ul>
</li>
<li>
<p><strong>Ecosystem Knowledge</strong>:</p>
<ul>
<li>DeFi/GameFi/DApp development</li>
<li>Layer2/IPFS/AMM implementation</li>
</ul>
</li>
<li>
<p><strong>Consensus Mechanisms</strong>:</p>
<ul>
<li>PoW/PoS/DPoS/PoH/PBFT</li>
</ul>
</li>
</ol>
<h4 id="computer-fundamentals"><a class="header" href="#computer-fundamentals"><strong>Computer Fundamentals</strong></a></h4>
<ul>
<li><strong>Networking</strong>: TCP/IP/HTTP/Socket programming</li>
<li><strong>Hardware</strong>: Router/Switch/Firewall configuration</li>
<li><strong>Rust</strong>: Ownership/Borrowing/Lifetime</li>
</ul>
<hr />
<h3 id="open-source-projects"><a class="header" href="#open-source-projects"><strong>Open Source Projects</strong></a></h3>
<h4 id="blockchain-interact-tools"><a class="header" href="#blockchain-interact-tools"><a href="https://github.com/codermaybe/BlockChain_InteractTools">Blockchain Interact Tools</a></a></h4>
<ul>
<li>Ethereum balance query</li>
<li>Contract interaction (view/pure methods)</li>
<li>Wallet management/transfer/seed phrase recovery</li>
</ul>
<h4 id="voting-system"><a class="header" href="#voting-system"><a href="https://github.com/codermaybe/VotingSystem">Voting System</a></a></h4>
<ul>
<li>V1: Single-project voting with admin control</li>
<li>V2: Multi-project voting with time-based rewards</li>
</ul>
<h4 id="solidity-contracts"><a class="header" href="#solidity-contracts"><a href="https://sepolia.etherscan.io/address/0x48aeCf60f7D272Dc118409CE5FB589386d4267eE">Solidity Contracts</a></a></h4>
<ul>
<li>Verified Ethereum testnet deployments</li>
</ul>
<h4 id="rust-subnet-tool"><a class="header" href="#rust-subnet-tool"><a href="https://github.com/codermaybe/IP_SubnetConverter_Flawed">Rust Subnet Tool</a></a></h4>
<ul>
<li>Windows route entry conversion utility</li>
</ul>
<h4 id="p2p-chat-system"><a class="header" href="#p2p-chat-system"><a href="https://github.com/codermaybe/display">P2P Chat System</a></a></h4>
<ul>
<li>LAN file transfer/messaging (Graduation Project)</li>
</ul>
<hr />
<h3 id="certifications"><a class="header" href="#certifications"><strong>Certifications</strong></a></h3>
<ul>
<li>CET-6: English technical documentation proficiency</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链blockchain"><a class="header" href="#区块链blockchain">区块链(BlockChain)</a></h1>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<blockquote>
<p>！为保证内容严谨性简介摘自<a href="https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666"> <strong>百度百科</strong></a>，可访问链接查证来源</p>
</blockquote>
<p>区块链（英文名：blockchain 或block chain ）是一种块链式存储、不可篡改、安全可信的<em><strong>去中心化分布式账本</strong></em> ，它结合了分布式存储、点对点传输、共识机制、密码学等技术，通过不断增长的数据块链（Blocks）记录交易和信息，确保数据的安全和透明性。</p>
<p>区块链起源于比特币（Bitcoin），最初由中本聪（Satoshi Nakamoto）在2008年提出，作为比特币的底层技术 。从诞生初期的比特币网络开始，区块链逐渐演化为一项全球性技术，吸引了全球的关注和投资。随后，以太坊（Ethereum）等新一代区块链平台的出现进一步扩展了应用领域 。</p>
<p>区块链的特点包括去中心化、不可篡改、透明、安全和可编程性。每个数据块都链接到前一个块，形成连续的链，保障了交易历史的完整性。智能合约技术使区块链可编程，支持更广泛的应用 。
区块链在金融、供应链、医疗、不动产等领域得到广泛应用。尽管仍面临可扩展性和法规挑战，但它已经成为改变传统商业和社会模式的强大工具，对未来具有巨大潜力。</p>
<hr />
<h2 id="当前区块链部分趋势解析"><a class="header" href="#当前区块链部分趋势解析">当前区块链部分趋势解析</a></h2>
<h4 id="1-加密货币数字金融的核心引擎"><a class="header" href="#1-加密货币数字金融的核心引擎">1. <strong>加密货币：数字金融的核心引擎</strong></a></h4>
<p>加密货币(常以比特币为人熟知)作为区块链技术的起点，依然是其最重要的应用之一。从比特币的价值存储功能到以太坊生态的智能合约支持，加密货币已经从单纯的投资工具扩展到支付、储值和跨境结算等实际场景。特别是稳定币（如 USDT、USDC）和央行数字货币（CBDC）正逐步成为全球金融体系的重要组成部分。</p>
<ul>
<li><strong>热点方向</strong>：
<ul>
<li>稳定币：提供低波动性的支付和储值工具。</li>
<li>数字资产：将现实世界资产（如房地产、股票）代币化。</li>
<li>隐私增强：如零知识证明技术（ZKP）推动隐私性支付。</li>
</ul>
</li>
<li><strong>未来展望</strong>：随着全球监管的逐步完善，加密货币将在合法合规的框架下，进一步融入主流经济。</li>
</ul>
<h4 id="2-数据存储构建去中心化存储网络"><a class="header" href="#2-数据存储构建去中心化存储网络">2. <strong>数据存储：构建去中心化存储网络</strong></a></h4>
<p>传统数据存储方式往往面临集中化风险，而区块链赋能的去中心化存储为这一问题提供了解决方案。通过分布式存储技术，数据不仅更安全，还能实现更高效的共享和访问。</p>
<ul>
<li><strong>代表技术</strong>：IPFS（星际文件系统）、Filecoin、Arweave。</li>
<li><strong>应用场景</strong>：
<ul>
<li>医疗数据：安全存储患者记录并防止数据泄露。</li>
<li>科研文献：永久存储科研成果，保证数据完整性。</li>
<li>数字资产：为 NFT 等提供长期存储支持。</li>
</ul>
</li>
<li><strong>未来展望</strong>：数据存储市场将进一步与人工智能和物联网结合，构建更大规模的数据共享网络。</li>
</ul>
<h4 id="3-版权保护为创作者经济注入新活力"><a class="header" href="#3-版权保护为创作者经济注入新活力">3. <strong>版权保护：为创作者经济注入新活力</strong></a></h4>
<p>数字时代，创作者面临着盗版泛滥和收益分配不透明的问题，而区块链的不可篡改特性为版权保护提供了新的解决方案。通过 NFT 和智能合约，创作者可以直接确权并实现收益的自动化分配。</p>
<ul>
<li><strong>技术工具</strong>：
<ul>
<li>NFT（非同质化代币）：用于数字艺术、音乐、视频的唯一性确权。</li>
<li>智能合约：实现收益分配的自动化和透明化。</li>
</ul>
</li>
<li><strong>代表项目</strong>：OpenSea、Async Art、Mintbase。</li>
<li><strong>未来展望</strong>：随着区块链技术与传统版权管理体系的深度结合，更多行业将采用去中心化方式管理和保护知识产权。</li>
</ul>
<h4 id="4-企业应用赋能实体经济的数字化转型"><a class="header" href="#4-企业应用赋能实体经济的数字化转型">4. <strong>企业应用：赋能实体经济的数字化转型</strong></a></h4>
<p>区块链技术在企业场景中的应用正在快速增长，尤其是在供应链、物流、金融清算等领域。企业通过区块链优化流程、降低成本，并提升数据透明度。</p>
<ul>
<li><strong>当前实践</strong>：
<ul>
<li>防伪溯源：确保商品从生产到销售的全程可追溯性。</li>
<li>合同管理：利用智能合约实现自动化履约。</li>
<li>资产管理：数字化管理企业资产，提高运营效率。</li>
</ul>
</li>
<li><strong>未来趋势</strong>：区块链将与物联网（IoT）、人工智能（AI）结合，构建智能化、自动化的企业运营网络。</li>
</ul>
<blockquote>
<p>区块链技术正以多维度的方式重塑各个行业。从加密货币到数据存储、版权保护，再到企业应用，其发展方向不仅展示了技术的潜力，也为数字经济与实体经济的深度融合开辟了新路径。在未来，我们有理由期待区块链技术在更多领域的突破和落地，推动社会迈向一个更加开放、透明、高效的新时代。</p>
</blockquote>
<h2 id="未来的可能"><a class="header" href="#未来的可能">未来的可能</a></h2>
<h4 id="1-跨链互操作性"><a class="header" href="#1-跨链互操作性">1. <strong>跨链互操作性</strong></a></h4>
<p>不同区块链之间的孤立性正在限制其大规模应用。未来，跨链技术将实现资产、数据和智能合约的跨链流通，为区块链生态系统的融合提供动力。</p>
<ul>
<li><strong>关键技术</strong>：Polkadot、Cosmos、桥接协议（Bridges）。</li>
<li><strong>潜在影响</strong>：
<ul>
<li>实现链间的无缝交互。</li>
<li>推动更多复杂场景的落地。</li>
</ul>
</li>
</ul>
<h4 id="2-隐私保护与合规"><a class="header" href="#2-隐私保护与合规">2. <strong>隐私保护与合规</strong></a></h4>
<p>随着数据隐私和合规性需求的增长，零知识证明（ZKP）、多方计算（MPC）等隐私增强技术将在金融、医疗等敏感数据场景中发挥重要作用。</p>
<ul>
<li><strong>技术前景</strong>：
<ul>
<li>更安全的隐私保护交易。</li>
<li>满足法规要求的合规区块链解决方案。</li>
</ul>
</li>
</ul>
<h4 id="3-web3-的普及"><a class="header" href="#3-web3-的普及">3. <strong>Web3 的普及</strong></a></h4>
<p>Web3 的发展将赋予用户对数据的完全掌控权，重新定义数字身份（DID）、去中心化存储和应用生态。</p>
<ul>
<li><strong>可能的变革</strong>：
<ul>
<li>用户数据自主权的增强。</li>
<li>去中心化社交媒体和内容平台的崛起。</li>
</ul>
</li>
</ul>
<h4 id="4-社会公益与可持续发展"><a class="header" href="#4-社会公益与可持续发展">4. <strong>社会公益与可持续发展</strong></a></h4>
<p>区块链技术可以支持公益透明化、碳排放追踪和绿色金融发展，为社会带来更多正向价值。</p>
<ul>
<li><strong>应用场景</strong>：
<ul>
<li>环保项目：追踪碳信用交易。</li>
<li>公益捐款：确保资金流向透明。</li>
</ul>
</li>
</ul>
<h2 id="疯狂的商机"><a class="header" href="#疯狂的商机">疯狂的商机</a></h2>
<h4 id="1-数字艺术与收藏品"><a class="header" href="#1-数字艺术与收藏品">1. <strong>数字艺术与收藏品</strong></a></h4>
<p>随着 NFT 的兴起，数字艺术市场呈现爆炸式增长。艺术家和创作者能够通过区块链直接向全球观众出售作品，同时确保所有权和版税收益。</p>
<ul>
<li><strong>商业模式</strong>：
<ul>
<li>创建独特的数字艺术品。</li>
<li>提供 NFT 交易和拍卖平台。</li>
</ul>
</li>
<li><strong>潜在利润</strong>：
<ul>
<li>高价值艺术品销售。</li>
<li>平台交易手续费收入。</li>
</ul>
</li>
</ul>
<h4 id="2-游戏经济和虚拟世界"><a class="header" href="#2-游戏经济和虚拟世界">2. <strong>游戏经济和虚拟世界</strong></a></h4>
<p>区块链赋能的游戏正重塑游戏行业，玩家可以真正拥有游戏内资产并通过交易获利。例如，"Play-to-Earn" 模式已吸引了大量玩家和投资者。</p>
<ul>
<li><strong>盈利模式</strong>：
<ul>
<li>虚拟道具销售。</li>
<li>游戏内资产的 NFT 化和交易。</li>
</ul>
</li>
<li><strong>成功案例</strong>：Axie Infinity、The Sandbox。</li>
</ul>
<h4 id="3-去中心化金融defi"><a class="header" href="#3-去中心化金融defi">3. <strong>去中心化金融（DeFi）</strong></a></h4>
<p>DeFi 提供了无需中介的金融服务，包括借贷、交易和收益农场。其透明性和高收益吸引了大量用户，成为区块链最具活力的领域之一。</p>
<ul>
<li><strong>商机</strong>：
<ul>
<li>创建创新性的 DeFi 协议。</li>
<li>提供流动性挖矿激励。</li>
</ul>
</li>
<li><strong>潜在收益</strong>：
<ul>
<li>协议交易费用。</li>
<li>流动性提供者的分红。</li>
</ul>
</li>
</ul>
<h4 id="4-元宇宙生态建设"><a class="header" href="#4-元宇宙生态建设">4. <strong>元宇宙生态建设</strong></a></h4>
<p>元宇宙作为一个虚拟与现实结合的世界，区块链是其关键技术之一。开发虚拟地产、虚拟商品以及元宇宙平台将成为新的商业热点。</p>
<ul>
<li><strong>盈利方向</strong>：
<ul>
<li>虚拟地产销售。</li>
<li>虚拟活动门票和商品交易。</li>
</ul>
</li>
<li><strong>未来前景</strong>：元宇宙将吸引更多品牌和用户，带来持续的商业机会。</li>
</ul>
<blockquote>
<p>区块链技术不仅在当前热点领域中发挥着重要作用，其未来可能性更是为人类社会的方方面面带来了无限想象空间。从技术突破到实际应用，区块链正在塑造一个更加开放、透明和可持续的未来。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>推荐链接：
<a href="https://dappradar.com">dappradar.com</a></p>
<h3 id="1-金融领域深化应用核心方向"><a class="header" href="#1-金融领域深化应用核心方向"><strong>1. 金融领域深化应用（核心方向）</strong></a></h3>
<ul>
<li><strong>去中心化金融（DeFi）</strong>：基于以太坊等公链构建借贷、交易、衍生品平台，2023年DeFi总锁仓量已突破千亿美元。</li>
<li><strong>供应链金融</strong>：通过区块链实现多方信息透明共享，降低信任成本，解决中小企业融资难题。</li>
<li><strong>跨境支付与结算</strong>：如瑞波币（Ripple）通过联盟链提升跨境支付效率，减少中间环节费用。</li>
<li><strong>数字资产证券化</strong>：利用智能合约实现资产Token化，提升流动性，典型案例如房地产和艺术品投资。</li>
</ul>
<hr />
<h3 id="2-企业级区块链解决方案主战场"><a class="header" href="#2-企业级区块链解决方案主战场"><strong>2. 企业级区块链解决方案（主战场）</strong></a></h3>
<ul>
<li><strong>联盟链与私有链主导</strong>：企业更倾向采用强管理的联盟链（如Hyperledger Fabric）优化供应链管理、数据存证等场景，提升协作效率。</li>
<li><strong>BaaS（区块链即服务）</strong>：云服务商（如AWS、阿里云）集成区块链模块，降低企业部署成本，加速应用落地。</li>
<li><strong>行业标准建设</strong>：金融、物流等领域制定区块链技术标准，如工信部发布的《区块链隐私保护规范》。</li>
</ul>
<hr />
<h3 id="3-跨行业扩展与实体经济融合"><a class="header" href="#3-跨行业扩展与实体经济融合"><strong>3. 跨行业扩展与实体经济融合</strong></a></h3>
<ul>
<li><strong>物联网与供应链管理</strong>：区块链+物联网实现设备数据可信上链，优化物流追踪与溯源（如IBM Food Trust）。</li>
<li><strong>医疗健康</strong>：患者数据加密共享，提升跨机构协作效率，同时保障隐私。</li>
<li><strong>政务与司法存证</strong>：多地政府采用区块链技术实现电子证照、司法证据存证，增强公信力。</li>
</ul>
<hr />
<h3 id="4-技术创新与生态扩展"><a class="header" href="#4-技术创新与生态扩展"><strong>4. 技术创新与生态扩展</strong></a></h3>
<ul>
<li><strong>跨链技术</strong>：解决多链互通问题，Polkadot、Cosmos等项目推动跨链协议发展，支撑价值互联网构建。</li>
<li><strong>Layer2扩容方案</strong>：如Optimism、zkSync通过Rollup技术提升以太坊交易吞吐量，降低Gas费用。</li>
<li><strong>隐私计算结合</strong>：零知识证明（ZKP）与同态加密技术增强交易隐私性，应用于匿名币（如Zcash）和合规金融场景。</li>
</ul>
<hr />
<h3 id="5-监管合规与标准化"><a class="header" href="#5-监管合规与标准化"><strong>5. 监管合规与标准化</strong></a></h3>
<ul>
<li><strong>STO（证券型代币）取代ICO</strong>：通过合规化代币发行降低风险，美国SEC已推动相关监管框架。</li>
<li><strong>全球监管协作</strong>：如区块链协会发布《数字资产市场结构原则》，强调保护用户自托管权利与跨境协作。</li>
<li><strong>反洗钱（AML）与KYC</strong>：各国要求交易所和钱包服务商纳入传统金融监管体系，如FATF“旅行规则”。</li>
</ul>
<hr />
<h3 id="6-新兴领域探索"><a class="header" href="#6-新兴领域探索"><strong>6. 新兴领域探索</strong></a></h3>
<ul>
<li><strong>Web3.0与去中心化身份（DID）</strong>：构建用户自主控制的数据身份体系，如以太坊的ERC-725标准。</li>
<li><strong>元宇宙与NFT</strong>：区块链支撑虚拟资产确权与交易，NFT应用扩展至游戏、艺术和知识产权领域。</li>
<li><strong>碳中和与能源管理</strong>：通过区块链追踪碳足迹，激励绿色能源交易，如Power Ledger项目。</li>
</ul>
<hr />
<h3 id="未来趋势关键点"><a class="header" href="#未来趋势关键点"><strong>未来趋势关键点</strong></a></h3>
<ol>
<li><strong>技术融合</strong>：区块链与AI、物联网、边缘计算结合，形成分布式信任网络。</li>
<li><strong>去中心化与监管平衡</strong>：在合规框架下探索DAO（去中心化自治组织）等新模式。</li>
<li><strong>基础设施升级</strong>：高性能公链（如Solana）和模块化架构（如Celestia）推动大规模商用。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作量证明-proof-of-work"><a class="header" href="#工作量证明-proof-of-work">工作量证明 (Proof of Work)</a></h1>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AD%89%E6%98%8E">文档推荐 - Wikipedia</a></p>
<ul>
<li><strong>代表币种</strong>: <a href="https://bitcoin.org/zh_CN/">Bitcoin</a>, <a href="https://ethereum.org/zh/">Ethereum（历史）</a>, <a href="https://dogecoin.com/">Dogecoin</a>, <a href="https://litecoin.com/">Litecoin</a>, <a href="https://www.dash.org/">Dash</a>, <a href="https://z.cash/">Zcash</a>, <a href="https://www.getmonero.org/">Monero</a></li>
</ul>
<hr />
<h1 id="深入浅出什么是pow共识机制"><a class="header" href="#深入浅出什么是pow共识机制">深入浅出：什么是PoW共识机制？</a></h1>
<p>如果你听说过比特币或区块链，可能对“挖矿”这个词不陌生。而挖矿的核心，就是 <strong>PoW（Proof of Work，工作量证明）</strong> 共识机制。本文将探讨PoW的定义、工作原理、优缺点及其历史背景。</p>
<h2 id="pow的本质"><a class="header" href="#pow的本质">PoW的本质</a></h2>
<p>PoW是一种通过计算“工作量”实现网络共识的机制。在区块链中，参与者（称为矿工）通过解决数学难题证明其投入的计算资源。成功解题的矿工可将新区块添加到链上并获得奖励。PoW依靠“工作量”的可验证性和高计算成本，确保系统的安全性和去中心化。</p>
<p>以比特币为例，其难题基于 <strong>SHA-256哈希函数</strong>：矿工需找到一个随机数（Nonce），使区块数据的哈希值满足特定条件（如具有一定数量的前导零）。这一过程需要大量试错计算，体现了PoW的“工作”特性。</p>
<h2 id="pow的工作原理"><a class="header" href="#pow的工作原理">PoW的工作原理</a></h2>
<ol>
<li><strong>交易收集</strong>：网络中的交易被打包进候选区块。</li>
<li><strong>难题挑战</strong>：矿工调整Nonce，反复计算哈希值，直到结果符合难度要求。</li>
<li><strong>验证答案</strong>：全网节点验证哈希是否有效，确保共识一致。</li>
<li><strong>广播与确认</strong>：有效区块被添加到区块链，矿工获得代币奖励。</li>
<li><strong>持续循环</strong>：过程重复，驱动区块链扩展。</li>
</ol>
<p>篡改区块需重算后续所有工作量，因算力竞争的存在，这种攻击成本极高，使得PoW网络高度安全。</p>
<h2 id="pow的优点"><a class="header" href="#pow的优点">PoW的优点</a></h2>
<ul>
<li><strong>安全性高</strong>：发起51%攻击需控制全网过半算力，在成熟网络（如比特币）中几乎不可行。</li>
<li><strong>去中心化</strong>：无需许可，任何拥有计算资源的个体均可参与。</li>
<li><strong>规则透明</strong>：奖励与算力直接相关，机制公开公平。</li>
</ul>
<h2 id="pow的缺点"><a class="header" href="#pow的缺点">PoW的缺点</a></h2>
<ul>
<li><strong>能耗巨大</strong>：高算力需求导致显著的电力消耗，引发环保争议。据估算，比特币网络年耗电量可媲美一些中小型国家。</li>
<li><strong>效率较低</strong>：交易吞吐量受限，例如比特币每秒处理约7笔交易。</li>
<li><strong>算力集中</strong>：专用设备（如ASIC）的普及使小型矿工难以竞争，算力逐渐向大矿池集中。</li>
</ul>
<h2 id="pow的历史背景与技术意义"><a class="header" href="#pow的历史背景与技术意义">PoW的历史背景与技术意义</a></h2>
<p>PoW的起源可以追溯到计算机科学和密码学的早期研究。1993年，<strong>Cynthia Dwork</strong> 和 <strong>Moni Naor</strong> 在一篇论文中提出了一种基于计算成本的方案，旨在防御垃圾邮件。他们设计了一种机制，要求发送者解决计算难题以证明诚意，这一想法成为PoW的雏形。1997年，<strong>Adam Back</strong> 推出了 <strong>Hashcash</strong>，利用SHA-1哈希函数生成特定难度的输出，用于抵御邮件轰炸和DDoS攻击。Hashcash直接启发了比特币的PoW设计。</p>
<p>2008年，<strong>中本聪（Satoshi Nakamoto）</strong> 在《比特币：一种点对点电子现金系统》白皮书中将PoW引入区块链，结合分布式账本和经济激励，解决了“双重支付”问题。中本聪的创新在于将Hashcash的单次证明扩展为动态调整难度的持续竞争机制，确保网络随算力增长保持约10分钟的出块时间。2009年1月3日，比特币创世区块生成，PoW成为首个成功运行的区块链共识算法。</p>
<p>早期，PoW被广泛采用，如Ethereum（2015-2022年）、Litecoin和Monero等。但随着技术进步，PoW的局限性显现。2022年9月15日，以太坊通过“The Merge”转向PoS，标志着对PoW的部分反思。尽管如此，PoW作为区块链技术的起点，其通过算力和数学建立信任的范式，开创了去中心化数字经济的先河。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="权益证明proof-of-stake"><a class="header" href="#权益证明proof-of-stake">权益证明(Proof of Stake)</a></h1>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E6%9C%89%E9%87%8F%E8%AD%89%E6%98%8E">文档推荐-wikipia</a></p>
<ul>
<li>代表链：ETH</li>
</ul>
<h1 id="深入浅出什么是pos共识机制"><a class="header" href="#深入浅出什么是pos共识机制">深入浅出：什么是PoS共识机制？</a></h1>
<p>如果你对比特币的PoW（工作量证明）有所了解，那么PoS（Proof of Stake，权益证明）可能是你听到的另一个热门共识机制。作为区块链技术的替代方案，PoS因其低能耗和高效率备受关注。今天，我们来聊聊PoS的原理、运作方式及其优缺点。</p>
<h2 id="pos的本质"><a class="header" href="#pos的本质">PoS的本质</a></h2>
<p>与PoW通过计算“工作量”不同，PoS基于参与者的“权益”来决定谁有权创建新区块。在PoS系统中，“权益”通常指用户持有的加密货币数量及其持有时间。简单来说，持有越多代币并“锁定”越久的人，越有可能被选中来验证交易并添加区块。这种机制用经济投入取代了算力竞争。</p>
<p>在PoS区块链中，验证者（Validator）不是通过挖矿，而是通过质押（Stake）代币参与共识。被选中的验证者负责打包交易并获得奖励，而作弊（如伪造区块）会导致质押的代币被没收。</p>
<h2 id="pos的工作原理"><a class="header" href="#pos的工作原理">PoS的工作原理</a></h2>
<ol>
<li><strong>质押代币</strong>：用户将一定数量的代币锁定在网络中，作为参与共识的“保证金”。</li>
<li><strong>随机选择</strong>：系统通过算法（通常结合代币数量和质押时间）随机选择一名验证者。</li>
<li><strong>区块创建</strong>：被选中的验证者验证交易并生成新区块。</li>
<li><strong>全网确认</strong>：其他节点验证区块的有效性，达成共识。</li>
<li><strong>奖励分配</strong>：验证者获得交易费或新发行的代币作为回报。</li>
</ol>
<p>PoS的关键在于“随机性”和“经济惩罚”：选择过程看似随机，但倾向于持有更多代币的参与者；若验证者行为不当，其质押的代币将被“销毁”。</p>
<h2 id="pos的优点"><a class="header" href="#pos的优点">PoS的优点</a></h2>
<ul>
<li><strong>能耗低</strong>：无需大量算力，PoS的能源消耗远低于PoW，更加环保。</li>
<li><strong>效率高</strong>：交易确认速度快，吞吐量更高（如以太坊PoS后可达数千TPS）。</li>
<li><strong>去中心化潜力</strong>：普通用户更容易参与，不依赖昂贵的挖矿设备。</li>
</ul>
<h2 id="pos的缺点"><a class="header" href="#pos的缺点">PoS的缺点</a></h2>
<ul>
<li><strong>富者愈富</strong>：持有更多代币的人更容易被选中，可能加剧财富集中。</li>
<li><strong>安全性争议</strong>：相比PoW，PoS对网络攻击（如“长程攻击”）的抵御能力仍需验证。</li>
<li><strong>初始分配问题</strong>：代币分配不均可能导致早期持有者占据主导。</li>
</ul>
<h2 id="pos的历史背景与技术意义"><a class="header" href="#pos的历史背景与技术意义">PoS的历史背景与技术意义</a></h2>
<p>PoS的概念最早出现在2011年，由QuantumMechanic在Bitcointalk论坛提出，旨在解决PoW的高能耗问题。2012年，Peercoin（PPC）成为首个采用PoS的加密货币项目，引入了“币龄”（Coin Age）的概念，即代币持有时间越长，获得记账权的概率越高。此后，PoS逐渐发展出多种变体，如纯PoS、DPoS（委托权益证明）和LPoS（租赁权益证明）。</p>
<p>以太坊的转型是PoS历史上的里程碑。2015年以太坊推出时采用PoW，但创始人Vitalik Buterin早已计划转向PoS。2022年9月15日，以太坊完成“合并”（The Merge），正式从PoW切换至PoS，成为迄今规模最大的PoS网络。这一转变不仅将能耗降低了约99.95%，还推动了PoS在主流区块链中的应用。</p>
<p>PoS的理论基础与博弈论和经济学密切相关。它假设参与者是理性的经济人，会因害怕失去质押资产而遵守规则。与PoW的算力竞争不同，PoS通过经济激励和惩罚构建信任，代表了区块链共识机制从“资源消耗”向“资源持有”的范式转变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-historypoh是什么"><a class="header" href="#proof-of-historypoh是什么">Proof of History（PoH）是什么？</a></h1>
<p><a href="https://solana.com/nl/news/proof-of-history">文档推荐 - Solana</a></p>
<p><strong>Proof of History（PoH，历史证明）</strong> 是由Solana团队开发的一种时间排序机制，旨在通过加密时间戳和可验证延迟函数（VDF）记录事件顺序，提升区块链的性能和可扩展性。PoH并非独立的共识算法，而是与Proof of Stake（PoS）结合使用，专注于解决分布式系统中时间同步的效率问题，为高吞吐量区块链提供了创新基础。</p>
<hr />
<h2 id="使用proof-of-historypoh的区块链项目"><a class="header" href="#使用proof-of-historypoh的区块链项目">使用Proof of History（PoH）的区块链项目</a></h2>
<p>以下是截至2025年2月28日，已知与PoH直接关联的区块链项目及其应用情况：</p>
<h3 id="1-solana"><a class="header" href="#1-solana">1. Solana</a></h3>
<ul>
<li><strong>概述</strong>：Solana是PoH的主要实现者，作为一个高性能Layer 1区块链，支持大规模去中心化应用（DApps）。</li>
<li><strong>PoH作用</strong>：Solana将PoH作为其架构的核心组件，与PoS结合。PoH通过生成连续的时间戳序列，标记交易和事件的顺序，减少节点间的时间同步需求，从而实现高吞吐量。</li>
<li><strong>特点</strong>：
<ul>
<li>高吞吐量：理论峰值超65,000 TPS，实际表现约为2,000-3,000 TPS（视网络状况）。</li>
<li>低延迟：区块时间约400毫秒。</li>
<li>应用场景：DeFi（如Serum）、NFT（如Magic Eden）、区块链游戏等。</li>
</ul>
</li>
<li><strong>现状</strong>：截至2025年，Solana已成为领先公链之一，其生态系统持续扩展。</li>
</ul>
<h3 id="2-filecoin探索性研究"><a class="header" href="#2-filecoin探索性研究">2. Filecoin（探索性研究）</a></h3>
<ul>
<li><strong>概述</strong>：Filecoin是一个去中心化存储网络，基于Proof of Replication（PoRep）和Proof of Spacetime（PoSt）。</li>
<li><strong>PoH关联</strong>：Filecoin本身不使用PoH，但社区和研究者曾探讨将其集成到架构中，以优化时间戳验证或存储证明效率。</li>
<li><strong>特点</strong>：
<ul>
<li>PoH可能提升数据检索的排序效率。</li>
<li>目前仅为理论提案，未在主网实现。</li>
</ul>
</li>
<li><strong>现状</strong>：PoH在Filecoin中未被正式采用，仅停留于实验讨论。</li>
</ul>
<h3 id="3-arweave潜在计划"><a class="header" href="#3-arweave潜在计划">3. Arweave（潜在计划）</a></h3>
<ul>
<li><strong>概述</strong>：Arweave是一个永久存储区块链，使用Proof of Access（PoA）和“Blockweave”结构。</li>
<li><strong>PoH关联</strong>：Arweave未正式采用PoH，但其团队曾提及探索类似时间排序机制的可能性，以改进数据验证效率。</li>
<li><strong>特点</strong>：
<ul>
<li>PoH或可优化交易顺序记录。</li>
<li>无明确证据显示已实现整合。</li>
</ul>
</li>
<li><strong>现状</strong>：截至2025年，PoH在Arweave中仍属概念性讨论，未进入实际部署。</li>
</ul>
<h3 id="其他相关项目"><a class="header" href="#其他相关项目">其他相关项目</a></h3>
<ul>
<li><strong>Hashgraph</strong>：Hedera Hashgraph是一种基于DAG的分布式账本技术，其事件排序机制与PoH有相似之处，但使用的是“Gossip about Gossip”和虚拟投票协议，非PoH。</li>
<li><strong>小型实验链</strong>：一些未具名的区块链项目可能在研究PoH，但缺乏公开文档和影响力，无法确认。</li>
</ul>
<h3 id="poh的应用前景"><a class="header" href="#poh的应用前景">PoH的应用前景</a></h3>
<p>PoH的核心优势在于高效的时间排序，使其适用于需要高吞吐量和低延迟的场景，如金融交易和实时应用。然而，VDF的计算需求可能限制普通节点参与，引发中心化争议。Solana的成功表明PoH的潜力，未来或有更多项目借鉴其设计。</p>
<hr />
<h2 id="poh的核心特点"><a class="header" href="#poh的核心特点">PoH的核心特点</a></h2>
<ol>
<li>
<p><strong>时间序列生成</strong><br />
PoH通过连续哈希运算生成不可篡改的时间记录，证明事件发生的顺序。</p>
</li>
<li>
<p><strong>与PoS协同</strong><br />
PoH不决定区块生产者，而是为PoS提供时间框架，由质押的验证者负责区块确认。</p>
</li>
<li>
<p><strong>高效性</strong><br />
通过本地计算替代网络通信，PoH显著提升交易处理速度。</p>
</li>
</ol>
<hr />
<h2 id="poh的工作原理"><a class="header" href="#poh的工作原理">PoH的工作原理</a></h2>
<p>PoH基于SHA-256哈希函数和可验证延迟函数（VDF），其运作流程如下：</p>
<ul>
<li>一个领导节点（Leader）持续运行哈希运算，将前一输出作为下一输入，形成单向的时间序列。</li>
<li>交易和事件嵌入此序列，记录其相对时间戳。</li>
<li>其他节点验证序列的正确性，因VDF的单向性，无需重新计算即可确认。</li>
<li>在Solana中，PoS验证者轮流担任领导者，根据PoH序列打包并确认区块。</li>
</ul>
<p>此设计将时间同步负担转移至本地计算，极大减少了网络通信开销。</p>
<hr />
<h2 id="poh的优缺点"><a class="header" href="#poh的优缺点">PoH的优缺点</a></h2>
<h3 id="优点"><a class="header" href="#优点">优点</a></h3>
<ul>
<li><strong>高吞吐量</strong>：支持数千至数万TPS，适用于大规模应用。</li>
<li><strong>低延迟</strong>：区块确认时间短，提升用户体验。</li>
<li><strong>可扩展性</strong>：为高性能区块链提供了技术支持。</li>
</ul>
<h3 id="缺点"><a class="header" href="#缺点">缺点</a></h3>
<ul>
<li><strong>硬件要求</strong>：生成PoH序列需要高性能硬件，可能提高参与门槛。</li>
<li><strong>集中化风险</strong>：领导节点的轮换若不平衡，可能削弱去中心化。</li>
<li><strong>应用范围有限</strong>：目前主要在Solana中实现，其他项目采用较少。</li>
</ul>
<hr />
<h2 id="poh的历史与愿景"><a class="header" href="#poh的历史与愿景">PoH的历史与愿景</a></h2>
<p>PoH由 <strong>Anatoly Yakovenko</strong> 于2017年首次提出，当时他试图解决分布式系统中时间协调的低效问题。传统共识如PoW依赖算力排序交易，耗能且缓慢；PoS虽降低能耗，仍需频繁通信以同步状态。Yakovenko受到密码学中VDF研究的启发，提出用加密手段生成时间序列，减少节点间依赖。</p>
<p>2018年2月，PoH在《Solana: A new architecture for a high performance blockchain》白皮书中正式亮相，结合PoS和VDF奠定了Solana的技术基础。2019年3月，Solana测试网上线，验证了PoH的可行性。2020年3月16日，Solana主网Beta版启动，PoH投入实际运行。此后，Solana凭借PoH实现的高性能迅速崛起，至2025年已成为公链领域的标杆。</p>
<p>未来，PoH可能在高吞吐量场景（如物联网、金融科技）中获得更多应用，尽管其硬件依赖性仍需优化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pbft共识机制"><a class="header" href="#pbft共识机制">PBFT共识机制</a></h1>
<p>在分布式系统和区块链领域，<strong>PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错）</strong> 是一种经典共识算法，旨在应对节点故障和恶意行为。</p>
<h2 id="pbft的本质"><a class="header" href="#pbft的本质">PBFT的本质</a></h2>
<p>PBFT由Miguel Castro和Barbara Liskov于1999年提出，用于解决拜占庭将军问题。它确保系统在至多1/3节点发生任意故障（包括恶意行为）时仍能达成一致，适用于节点数量有限的分布式网络。</p>
<h2 id="pbft的工作原理"><a class="header" href="#pbft的工作原理">PBFT的工作原理</a></h2>
<p>PBFT通过三阶段协议实现共识，假设总节点数<code>n</code>，最大容错节点数<code>f</code>，需满足<code>n ≥ 3f + 1</code>：</p>
<ol>
<li><strong>预准备（Pre-prepare）</strong>：主节点接收客户端请求，分配序列号并广播提议。</li>
<li><strong>准备（Prepare）</strong>：各节点验证提议合法性，广播准备消息，需收到<code>2f + 1</code>个一致确认。</li>
<li><strong>提交（Commit）</strong>：节点收到<code>2f + 1</code>个准备确认后广播提交，达成共识并执行。</li>
</ol>
<p>若主节点失效，视图切换（View Change）机制触发，选举新主节点。通信复杂度为<code>O(n²)</code>。</p>
<h2 id="pbft的优缺点"><a class="header" href="#pbft的优缺点">PBFT的优缺点</a></h2>
<h3 id="优点-1"><a class="header" href="#优点-1">优点</a></h3>
<ul>
<li><strong>强容错性</strong>：可容忍不超过<code>(n-1)/3</code>个拜占庭节点。</li>
<li><strong>高效性</strong>：无需算力竞争，延迟低。</li>
<li><strong>最终性</strong>：达成共识后状态不可逆。</li>
</ul>
<h3 id="缺点-1"><a class="header" href="#缺点-1">缺点</a></h3>
<ul>
<li><strong>扩展性差</strong>：节点数增加时通信开销激增。</li>
<li><strong>前提条件</strong>：需已知节点身份，不适合完全开放系统。</li>
</ul>
<h2 id="pbft的应用"><a class="header" href="#pbft的应用">PBFT的应用</a></h2>
<p>PBFT常见于许可链，如Hyperledger Fabric的共识模块，以及Tendermint（Cosmos SDK基础）。它适用于金融、供应链等需高效一致性的场景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hotstuff共识机制区块链中的高效bft解决方案"><a class="header" href="#hotstuff共识机制区块链中的高效bft解决方案">HotStuff共识机制：区块链中的高效BFT解决方案</a></h1>
<p><a href="https://medium.com/@Elifhilalumucu/understanding-hotstuff-and-byzantine-fault-tolerance-393ca878173f">推荐博文-英</a>
<a href="https://dl.acm.org/doi/10.1145/3293611.3331591">推荐论文</a>
<a href="https://zhuanlan.zhihu.com/p/150705698">知乎</a></p>
<h2 id="引言"><a class="header" href="#引言">引言</a></h2>
<p>在分布式系统和区块链技术中，共识机制是确保节点间状态一致性的核心组件。传统的拜占庭容错（Byzantine Fault Tolerance, BFT）协议，如PBFT（Practical Byzantine Fault Tolerance），在安全性上表现出色，但在通信复杂度和性能扩展性上面临挑战。HotStuff作为一种新型的BFT共识协议，结合了高效性、响应性（responsiveness）和线性通信复杂度，成为近年来备受关注的解决方案。</p>
<blockquote>
<p>HotStuff作为一种创新的BFT共识协议，通过三阶段投票、线性通信和管道化设计，为区块链和分布式系统提供了高效、安全的解决方案。它不仅改进了传统BFT协议的扩展性瓶颈，还为现代区块链应用奠定了技术基础。尽管存在一些局限性，但其设计理念和实践价值已得到广泛认可。随着研究的深入，HotStuff及其变种有望在更多场景中发挥作用，推动分布式共识技术的进一步发展。</p>
</blockquote>
<h2 id="hotstuff概述"><a class="header" href="#hotstuff概述">HotStuff概述</a></h2>
<p>HotStuff由VMware Research团队于2018年提出，并在2019年的PODC会议上正式发表。它是一种基于领导者（leader-based）的BFT共识协议，运行于部分同步（partially synchronous）网络模型中。HotStuff的目标是解决传统BFT协议（如PBFT）的痛点，同时满足区块链系统对高吞吐量、低延迟和可扩展性的需求。</p>
<p>HotStuff的关键特性包括：</p>
<ol>
<li><strong>响应性（Responsiveness）</strong>：在网络通信同步后，协议的推进速度取决于实际网络延迟，而非预设的最大延迟。</li>
<li><strong>线性通信复杂度</strong>：通过优化通信模式，HotStuff将通信开销从传统BFT的平方级别（O(n²)）降低到线性级别（O(n)）。</li>
<li><strong>三阶段提交规则</strong>：采用独特的“三链”（Three-Chain）提交规则，确保安全性和活跃性（liveness）。</li>
<li><strong>领导者轮换</strong>：支持频繁的领导者替换，提升系统鲁棒性。</li>
</ol>
<p>HotStuff的这些特性使其成为Facebook（现Meta）的Libra（后更名为Diem）项目中LibraBFT共识协议的基础。</p>
<h2 id="hotstuff的核心设计"><a class="header" href="#hotstuff的核心设计">HotStuff的核心设计</a></h2>
<h3 id="1-系统模型"><a class="header" href="#1-系统模型">1. 系统模型</a></h3>
<p>HotStuff假设一个由n个节点组成的系统，其中最多f个节点可能出现拜占庭故障（n ≥ 3f + 1）。网络模型为部分同步，即存在一个未知的全局稳定时间（GST），在此之前网络可能是异步的，之后变为同步。节点通过消息传递进行通信，所有消息均经过数字签名以确保不可伪造。</p>
<h3 id="2-三阶段协议"><a class="header" href="#2-三阶段协议">2. 三阶段协议</a></h3>
<p>HotStuff的核心是其三阶段投票机制，与PBFT的两阶段（Pre-Prepare和Commit）不同。HotStuff的三个阶段分别为：</p>
<ul>
<li><strong>Prepare</strong>：领导者提出一个新区块，收集至少2f+1个节点的投票，形成Prepare Quorum Certificate（Prepare QC）。</li>
<li><strong>Pre-Commit</strong>：领导者广播Prepare QC，节点验证后投票，领导者收集2f+1个投票形成Pre-Commit QC。</li>
<li><strong>Commit</strong>：领导者广播Pre-Commit QC，节点投票并锁定该提案，领导者收集2f+1个投票形成Commit QC，完成提交。</li>
</ul>
<p>每个阶段的投票都被聚合为一个Quorum Certificate（QC），通过阈值签名（threshold signature）实现高效验证。相比PBFT，额外的Pre-Commit阶段解决了“隐藏锁”（hidden lock）问题，确保新领导者在视图切换（view change）时能安全接管。</p>
<h3 id="3-线性通信复杂度"><a class="header" href="#3-线性通信复杂度">3. 线性通信复杂度</a></h3>
<p>传统BFT协议（如PBFT）在视图切换时需要所有节点广播其状态，导致通信复杂度为O(n²)。HotStuff通过“星型通信”（star communication）优化了这一过程：</p>
<ul>
<li>节点仅与当前领导者通信，发送投票。</li>
<li>领导者聚合投票并广播QC。</li>
</ul>
<p>这种模式将通信复杂度降至O(n)，显著提高了协议的可扩展性，尤其在节点数量较多时优势明显。</p>
<h3 id="4-领导者轮换与管道化"><a class="header" href="#4-领导者轮换与管道化">4. 领导者轮换与管道化</a></h3>
<p>HotStuff支持频繁的领导者轮换，每轮共识后可更换领导者，增强了系统的公平性和抗攻击能力。此外，HotStuff引入了“链式”（Chained）设计，将多个区块的共识过程管道化：</p>
<ul>
<li>一个区块的Prepare QC可作为下一个区块的依据。</li>
<li>通过连续的“三链”结构（Prepare → Pre-Commit → Commit），实现高吞吐量。</li>
</ul>
<p>例如，当第N个区块完成Commit时，第N+1个区块可能已进入Pre-Commit，第N+2个区块进入Prepare。这种管道化设计充分利用了网络带宽，提升了整体性能。</p>
<h3 id="5-安全性和活跃性"><a class="header" href="#5-安全性和活跃性">5. 安全性和活跃性</a></h3>
<ul>
<li><strong>安全性（Safety）</strong>：HotStuff通过三阶段投票和QC锁定机制，确保不会出现冲突提交。即使在异步网络中，只要不超过f个节点故障，协议仍是安全的。</li>
<li><strong>活跃性（Liveness）</strong>：通过Pacemaker机制（超时触发视图切换），HotStuff保证在GST后，系统能在正确领导者的带领下达成共识。</li>
</ul>
<h2 id="hotstuff与pbft的对比"><a class="header" href="#hotstuff与pbft的对比">HotStuff与PBFT的对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>PBFT</th><th>HotStuff</th></tr></thead><tbody>
<tr><td>通信复杂度</td><td>O(n²)</td><td>O(n)</td></tr>
<tr><td>投票阶段</td><td>两阶段</td><td>三阶段</td></tr>
<tr><td>响应性</td><td>无</td><td>有</td></tr>
<tr><td>领导者替换</td><td>复杂且开销大</td><td>简单且高效</td></tr>
<tr><td>管道化支持</td><td>无</td><td>有</td></tr>
</tbody></table>
</div>
<p>HotStuff在通信效率和灵活性上优于PBFT，尤其适用于大规模分布式系统。</p>
<h2 id="hotstuff在区块链中的应用"><a class="header" href="#hotstuff在区块链中的应用">HotStuff在区块链中的应用</a></h2>
<p>HotStuff因其高效性和可扩展性，被广泛应用于许可型区块链（permissioned blockchain）场景：</p>
<ol>
<li><strong>LibraBFT</strong>：Libra项目的共识协议直接基于HotStuff，优化了其在金融场景下的性能。</li>
<li><strong>SafeStake</strong>：一个支持以太坊2.0 staking的中间层协议，利用HotStuff提升去中心化程度。</li>
<li><strong>Cypherium</strong>：结合HotStuff与PoW，探索混合共识的可能性。</li>
</ol>
<p>在这些应用中，HotStuff通过线性通信和管道化设计，显著提升了交易吞吐量和确认速度，同时保持了BFT的安全性。</p>
<h2 id="优势与局限性"><a class="header" href="#优势与局限性">优势与局限性</a></h2>
<h3 id="优势"><a class="header" href="#优势">优势</a></h3>
<ul>
<li><strong>高性能</strong>：线性通信和管道化实现高吞吐量和低延迟。</li>
<li><strong>可扩展性</strong>：适用于大规模节点网络。</li>
<li><strong>鲁棒性</strong>：频繁领导者轮换减少单点故障风险。</li>
</ul>
<h3 id="局限性"><a class="header" href="#局限性">局限性</a></h3>
<ul>
<li><strong>延迟增加</strong>：三阶段设计在正常情况下比两阶段协议多一次通信。</li>
<li><strong>复杂性</strong>：管道化和阈值签名的实现对开发和调试提出了更高要求。</li>
<li><strong>性能攻击脆弱性</strong>：在某些情况下，恶意节点可能通过分叉攻击降低吞吐量。</li>
</ul>
<p>针对这些问题，后续研究提出了改进版本，如Fast-HotStuff（两阶段优化）和HotStuff-2（简化投票流程），进一步提升效率和鲁棒性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethereum"><a class="header" href="#ethereum">Ethereum</a></h1>
<h2 id="概览官方介绍"><a class="header" href="#概览官方介绍">概览(<a href="https://ethereum.org/zh/what-is-ethereum/">官方介绍</a>)</a></h2>
<p>什么是以太坊？</p>
<blockquote>
<p>以太坊是一个由世界各地的计算机组成的网络，遵循一套称为以太坊协议的规则。以太坊网络提供了一个基础，任何人都可以在上面构建和使用社区、应用程序、组织和数字资产。</p>
</blockquote>
<p>谁在运行以太坊？</p>
<blockquote>
<p>以太坊不受任何特定实体控制。只要计算机运行遵循以太坊协议的软件，相互连接，并为以太坊区块链添加区块，以太坊就会存在。其中每一台计算机都被称为节点。任何人都可以运行节点，但必须要质押以太币（以太坊的原生代币）才能参与保护网络安全的工作。任何人无需许可，都可以用 32 个以太币参与质押。
甚至以太坊的源代码也不是由单个实体生成的。任何人都可以建议更改协议并讨论升级。有一些以太坊协议的实现是由独立组织用多种编程语言完成的，它们通常建立在开放的基础上并鼓励来自社区的贡献。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="以太坊基础"><a class="header" href="#以太坊基础">以太坊基础</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc"><a class="header" href="#erc">ERC</a></h1>
<p>ERC 是 Ethereum Request for Comments（以太坊请求评论）的缩写。它是以太坊社区定义的一系列智能合约标准。这些标准为以太坊上的智能合约开发提供了规则和指南，确保不同开发者创建的合约能够相互交互和兼容。</p>
<p><a href="https://github.com/ethereum/ERCs/tree/master/ERCS">官方文档</a></p>
<hr />
<h1 id="erc-的主要作用"><a class="header" href="#erc-的主要作用">ERC 的主要作用</a></h1>
<h2 id="互操作性"><a class="header" href="#互操作性">互操作性</a></h2>
<p>在以太坊生态系统中 ，不同的开发者可能会创建各种各样的智能合约。ERC 标准允许这些合约以一种统一的方式进行交互。例如，在去中心化金融（DeFi）领域，有许多不同的应用程序，如借贷平台、去中心化交易所等。ERC - 20 标准的存在使得各种通证能够在这些不同的平台之间方便地流通和交易。</p>
<h2 id="标准化开发"><a class="header" href="#标准化开发">标准化开发</a></h2>
<p>为开发者提供了清晰的开发指南。以 ERC - 721 为例，这个标准专门用于非同质化通证（NFT）。它规定了 NFT 合约必须实现的一些基本方法，如balanceOf（查询某个地址拥有的 NFT 数量）、ownerOf（查询某个 NFT 的所有者）和transferFrom（转移 NFT 的所有权）等。这使得开发者在创建 NFT 项目时能够遵循一套既定的规则，减少开发过程中的混乱，并确保所开发的 NFT 能够被市场上的各种钱包和应用程序所支持。</p>
<h1 id="常见的-erc-标准"><a class="header" href="#常见的-erc-标准">常见的 ERC 标准</a></h1>
<h2 id="erc---20"><a class="header" href="#erc---20">ERC - 20</a></h2>
<p>这是最著名的 ERC 标准之一，主要用于创建可互换的数字资产，也就是同质化通证。在以太坊上发行的大多数加密货币（如以太坊本身之外的许多山寨币）都遵循 ERC - 20 标准。它定义了一套接口，包括totalSupply（总供应量）、balanceOf（账户余额）、transfer（转账）、transferFrom（授权转账）、approve（授权）等方法。</p>
<h2 id="erc---721"><a class="header" href="#erc---721">ERC - 721：</a></h2>
<p>专为非同质化通证（NFT）设计。与 ERC - 20 不同，ERC - 721 中的每个通证都是独一无二的，不能与其他通证互换。NFT 在数字艺术、游戏道具、虚拟房地产等领域有广泛的应用。通过 ERC - 721 标准，这些独特的资产可以在以太坊区块链上安全地创建、拥有和交易。</p>
<h2 id="erc---1155"><a class="header" href="#erc---1155">ERC - 1155：</a></h2>
<p>这是一种多令牌标准，它结合了 ERC - 20 和 ERC - 721 的特点。ERC - 1155 允许在一个智能合约中同时管理多种类型的通证，包括同质化和非同质化通证。这种标准在游戏开发等场景中特别有用，因为游戏中可能同时存在可互换的游戏货币和独一无二的游戏道具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<p>ERC-20 标准的 ABI 是一组函数和事件定义，用于在以太坊上实现可互换的代币标准。ERC-20 代币标准由以太坊社区提出，定义了一组基础接口和功能，如余额查询、转账和授权等。</p>
<h3 id="erc-20-标准-abi"><a class="header" href="#erc-20-标准-abi">ERC-20 标准 ABI</a></h3>
<p>以下是 <strong>ERC-20 标准 ABI</strong>，用于与符合 ERC-20 标准的合约进行交互：</p>
<pre><code class="language-json">[
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "balance", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {"name": "_to", "type": "address"},
      {"name": "_value", "type": "uint256"}
    ],
    "name": "transfer",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {"name": "_spender", "type": "address"},
      {"name": "_value", "type": "uint256"}
    ],
    "name": "approve",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {"name": "_owner", "type": "address"},
      {"name": "_spender", "type": "address"}
    ],
    "name": "allowance",
    "outputs": [{"name": "", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {"name": "_from", "type": "address"},
      {"name": "_to", "type": "address"},
      {"name": "_value", "type": "uint256"}
    ],
    "name": "transferFrom",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "owner", "type": "address"},
      {"indexed": true, "name": "spender", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "from", "type": "address"},
      {"indexed": true, "name": "to", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{"name": "", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [{"name": "", "type": "string"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{"name": "", "type": "string"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [{"name": "", "type": "uint8"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
]
</code></pre>
<hr />
<h3 id="erc-20-abi-说明"><a class="header" href="#erc-20-abi-说明">ERC-20 ABI 说明</a></h3>
<ul>
<li>
<p><strong>Functions</strong>：</p>
<ul>
<li><code>totalSupply</code>：返回代币的总供应量。</li>
<li><code>balanceOf</code>：查询指定地址的余额。</li>
<li><code>transfer</code>：从发送者地址向指定地址发送代币。</li>
<li><code>approve</code>：批准某个地址可以花费指定数量的代币。</li>
<li><code>allowance</code>：查询某个地址对另一个地址授权的代币数量。</li>
<li><code>transferFrom</code>：从指定地址向另一个地址转移代币（需要先批准）。</li>
</ul>
</li>
<li>
<p><strong>Events</strong>：</p>
<ul>
<li><code>Transfer</code>：代币转移事件，记录从一个地址向另一个地址转移的情况。</li>
<li><code>Approval</code>：授权事件，记录某个地址被授权花费代币。</li>
</ul>
</li>
<li>
<p><strong>Metadata Functions</strong>（非强制但通常包含）：</p>
<ul>
<li><code>name</code>：代币的名称。</li>
<li><code>symbol</code>：代币的符号。</li>
<li><code>decimals</code>：代币的小数位数，通常是 18。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="如何使用-erc-20-abi"><a class="header" href="#如何使用-erc-20-abi">如何使用 ERC-20 ABI</a></h3>
<p>使用上面的 ABI 和 <code>web3.js</code> 或 <code>ethers.js</code> 库，可以轻松与符合 ERC-20 标准的智能合约交互。</p>
<h4 id="使用-ethersjs-示例"><a class="header" href="#使用-ethersjs-示例">使用 <code>ethers.js</code> 示例：</a></h4>
<h4 id="使用-web3js-示例"><a class="header" href="#使用-web3js-示例">使用 <code>web3.js</code> 示例：</a></h4>
<pre><code class="language-javascript">const Web3 = require('web3');
const web3 = new Web3('https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID');

const erc20ABI = [/* 这里粘贴上面的 ERC-20 ABI */];
const contractAddress = '0xTokenContractAddress'; // 替换为 ERC-20 代币合约地址

const erc20Contract = new web3.eth.Contract(erc20ABI, contractAddress);

erc20Contract.methods.balanceOf('0xYourAddress').call()
  .then(balance =&gt; console.log(`Token Balance: ${balance}`));
</code></pre>
<hr />
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>ERC-20 标准 ABI 包含了代币的核心功能，如代币转移、余额查询和授权操作。通过使用此标准的 ABI，你可以与任何 ERC-20 兼容的合约进行交互。</p>
<h1 id="如何调用任意erc20合约"><a class="header" href="#如何调用任意erc20合约">如何调用任意ERC20合约</a></h1>
<p>详见github项目<a href="https://github.com/codermaybe/BlockChain_InteractTools/graphs/traffic">BlockChain_InteractTools</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc721概念"><a class="header" href="#erc721概念">ERC721概念</a></h1>
<p><a href="https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/">推荐链接-ethereum</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ethersjs-通过私钥还原公钥"><a class="header" href="#ethersjs-通过私钥还原公钥">Ethers.js 通过私钥还原公钥</a></h3>
<h4 id="一什么是私钥和公钥"><a class="header" href="#一什么是私钥和公钥">一、什么是私钥和公钥？</a></h4>
<p>在以太坊和其他区块链平台中，私钥是一个源信息，用于命令链上账户进行操作。公钥则是从私钥中运算出的，用于验证操作的合法性和完整性。</p>
<h4 id="二安装-ethersjs"><a class="header" href="#二安装-ethersjs">二、安装 ethers.js</a></h4>
<p>在实现私钥还原公钥之前，需要先安装 <code>ethers.js</code>：</p>
<pre><code class="language-bash">npm install ethers
</code></pre>
<h4 id="三使用-ethersjs-运算公钥"><a class="header" href="#三使用-ethersjs-运算公钥">三、使用 ethers.js 运算公钥</a></h4>
<p>以下是通过 ethers.js 将私钥转换为公钥的完整代码：</p>
<pre><code class="language-javascript">const { Wallet } = require('ethers');

// 私钥（确保保密！）
const privateKey = "0x1e99423a701fcf82f4888e3e23b6c1840ad48d360bb8bc1239e0c7ff8ecf743d";

// 从私钥生成钥包实例
const wallet = new Wallet(privateKey);

// 获取公钥
const publicKey = wallet.publicKey;

console.log("私钥:", privateKey);
console.log("公钥:", publicKey);
</code></pre>
<h5 id="输出格式"><a class="header" href="#输出格式">输出格式</a></h5>
<ul>
<li><strong>私钥</strong>：输入值，64 个十六进制字符，前缀为 <code>0x</code>。</li>
<li><strong>公钥</strong>：未压缩格式，524-bit （含前缀 <code>0x04</code>），起始为一个指针。</li>
</ul>
<h5 id="示例输出"><a class="header" href="#示例输出">示例输出</a></h5>
<pre><code>私钥: 0x1e99423a701fcf82f4888e3e23b6c1840ad48d360bb8bc1239e0c7ff8ecf743d
公钥: 0x04bfcab4e67d19d84cf2047269de360f3e51b50fa5c45594f5365ff3c7ec8f3f482c909de42ccadf81a913e51e535fc327fced47adf968f2bf4bfdbc5f8862bb2d
</code></pre>
<h4 id="四运算原理解析"><a class="header" href="#四运算原理解析">四、运算原理解析</a></h4>
<h5 id="使用的替代secp256k1"><a class="header" href="#使用的替代secp256k1">使用的替代：<code>secp256k1</code></a></h5>
<p><code>ethers.js</code> 使用了 <code>secp256k1</code> 椭圆曲线，这是比特币和以太坊等区块链系统使用的标准曲线。<code>secp256k1</code> 定义了一个椭圆曲线方程：<code>y^2 = x^3 + 7</code>，并基于此定义了一个基点 G。公钥是通过私钥对基点 G 进行椭圆曲线点乘计算得出的。这个过程确保了私钥与公钥之间的唯一性和安全性，同时公钥可以公开用于验证签名的合法性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usdc源码解析"><a class="header" href="#usdc源码解析">USDC源码解析</a></h1>
<p><a href="https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code">USDC 源码链接</a></p>
<p>V1设计结构
<img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./img/image.png" alt="alt text" /></p>
<h2 id="逐模块分析"><a class="header" href="#逐模块分析">逐模块分析</a></h2>
<h3 id="fiattokenv1sol--主要实现"><a class="header" href="#fiattokenv1sol--主要实现">FiatTokenV1.sol  (主要实现)</a></h3>
<p><a href="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./sourcecode/FiatTokenV1/FiatTokenV1.html">FiatTokenV1</a></p>
<h3 id="ownablesol"><a class="header" href="#ownablesol">ownable.sol</a></h3>
<p><a href="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./sourcecode/Ownable/Ownable.html">ownable</a></p>
<h3 id="pauseablesol"><a class="header" href="#pauseablesol">pauseable.sol</a></h3>
<p><a href="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./sourcecode/Pauseable/Pauseable.html">pauseable</a></p>
<h3 id="abstractfiattokenv1sol"><a class="header" href="#abstractfiattokenv1sol">AbstractFiatTokenV1.sol</a></h3>
<p><a href="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./sourcecode/AbstractFiatTokenV1/AbstractFiatTokenV1.html">AbstractFiatTokenV1</a></p>
<h3 id="blacklistablesol"><a class="header" href="#blacklistablesol">Blacklistable.sol</a></h3>
<p><a href="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/./sourcecode/Blacklistable/Blacklistable.html">Blacklistable</a></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/sourcecode/Ownable/ownable.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: MIT
 *
 * Copyright (c) 2018 zOS Global Limited.
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @notice The Ownable contract has an owner address, and provides basic
 * authorization control functions
 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-labs/blob/3887ab77b8adafba4a26ace002f3a684c1a3388b/upgradeability_ownership/contracts/ownership/Ownable.sol
 * Modifications:
 * 1. Consolidate OwnableStorage into this contract (7/13/18)
 * 2. Reformat, conform to Solidity 0.6 syntax, and add error messages (5/13/20)
 * 3. Make public functions external (5/27/20)
 */
contract Ownable {
    // Owner of the contract
    address private _owner;

    /**
     * @dev Event to show ownership has been transferred
     * @param previousOwner representing the address of the previous owner
     * @param newOwner representing the address of the new owner
     */
    event OwnershipTransferred(address previousOwner, address newOwner);

    /**
     * @dev The constructor sets the original owner of the contract to the sender account.
     */
    constructor() public {
        setOwner(msg.sender);
    }

    /**
     * @dev Tells the address of the owner
     * @return the address of the owner
     */
    function owner() external view returns (address) {
        return _owner;
    }

    /**
     * @dev Sets a new owner address
     */
    function setOwner(address newOwner) internal {
        _owner = newOwner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == _owner, "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        setOwner(newOwner);
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/sourcecode/Pauseable/Pauseable.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: MIT
 *
 * Copyright (c) 2016 Smart Contract Solutions, Inc.
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

import { Ownable } from "./Ownable.sol";

/**
 * @notice Base contract which allows children to implement an emergency stop
 * mechanism
 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/feb665136c0dae9912e08397c1a21c4af3651ef3/contracts/lifecycle/Pausable.sol
 * Modifications:
 * 1. Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)
 * 2. Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)
 * 3. Removed whenPaused (6/14/2018)
 * 4. Switches ownable library to use ZeppelinOS (7/12/18)
 * 5. Remove constructor (7/13/18)
 * 6. Reformat, conform to Solidity 0.6 syntax and add error messages (5/13/20)
 * 7. Make public functions external (5/27/20)
 */
contract Pausable is Ownable {
    event Pause();
    event Unpause();
    event PauserChanged(address indexed newAddress);

    address public pauser;
    bool public paused = false;

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!paused, "Pausable: paused");
        _;
    }

    /**
     * @dev throws if called by any account other than the pauser
     */
    modifier onlyPauser() {
        require(msg.sender == pauser, "Pausable: caller is not the pauser");
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyPauser {
        paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyPauser {
        paused = false;
        emit Unpause();
    }

    /**
     * @notice Updates the pauser address.
     * @param _newPauser The address of the new pauser.
     */
    function updatePauser(address _newPauser) external onlyOwner {
        require(
            _newPauser != address(0),
            "Pausable: new pauser is the zero address"
        );
        pauser = _newPauser;
        emit PauserChanged(pauser);
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/sourcecode/AbstractFiatTokenV1/AbstractFiatTokenV1.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright (c) 2023, Circle Internet Financial, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pragma solidity 0.6.12;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

abstract contract AbstractFiatTokenV1 is IERC20 {
    function _approve(
        address owner,
        address spender,
        uint256 value
    ) internal virtual;

    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal virtual;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/sourcecode/Blacklistable/Blacklistable.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright (c) 2023, Circle Internet Financial, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pragma solidity 0.6.12;

import { Ownable } from "./Ownable.sol";

/**
 * @title Blacklistable Token
 * @dev Allows accounts to be blacklisted by a "blacklister" role
 */
abstract contract Blacklistable is Ownable {
    address public blacklister;
    mapping(address =&gt; bool) internal _deprecatedBlacklisted;

    event Blacklisted(address indexed _account);
    event UnBlacklisted(address indexed _account);
    event BlacklisterChanged(address indexed newBlacklister);

    /**
     * @dev Throws if called by any account other than the blacklister.
     */
    modifier onlyBlacklister() {
        require(
            msg.sender == blacklister,
            "Blacklistable: caller is not the blacklister"
        );
        _;
    }

    /**
     * @dev Throws if argument account is blacklisted.
     * @param _account The address to check.
     */
    modifier notBlacklisted(address _account) {
        require(
            !_isBlacklisted(_account),
            "Blacklistable: account is blacklisted"
        );
        _;
    }

    /**
     * @notice Checks if account is blacklisted.
     * @param _account The address to check.
     * @return True if the account is blacklisted, false if the account is not blacklisted.
     */
    function isBlacklisted(address _account) external view returns (bool) {
        return _isBlacklisted(_account);
    }

    /**
     * @notice Adds account to blacklist.
     * @param _account The address to blacklist.
     */
    function blacklist(address _account) external onlyBlacklister {
        _blacklist(_account);
        emit Blacklisted(_account);
    }

    /**
     * @notice Removes account from blacklist.
     * @param _account The address to remove from the blacklist.
     */
    function unBlacklist(address _account) external onlyBlacklister {
        _unBlacklist(_account);
        emit UnBlacklisted(_account);
    }

    /**
     * @notice Updates the blacklister address.
     * @param _newBlacklister The address of the new blacklister.
     */
    function updateBlacklister(address _newBlacklister) external onlyOwner {
        require(
            _newBlacklister != address(0),
            "Blacklistable: new blacklister is the zero address"
        );
        blacklister = _newBlacklister;
        emit BlacklisterChanged(blacklister);
    }

    /**
     * @dev Checks if account is blacklisted.
     * @param _account The address to check.
     * @return true if the account is blacklisted, false otherwise.
     */
    function _isBlacklisted(address _account)
        internal
        virtual
        view
        returns (bool);

    /**
     * @dev Helper method that blacklists an account.
     * @param _account The address to blacklist.
     */
    function _blacklist(address _account) internal virtual;

    /**
     * @dev Helper method that unblacklists an account.
     * @param _account The address to unblacklist.
     */
    function _unBlacklist(address _account) internal virtual;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1/sourcecode/FiatTokenV1/FiatTokenV1.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright (c) 2023, Circle Internet Financial, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pragma solidity 0.6.12;

import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { AbstractFiatTokenV1 } from "./AbstractFiatTokenV1.sol";
import { Ownable } from "./Ownable.sol";
import { Pausable } from "./Pausable.sol";
import { Blacklistable } from "./Blacklistable.sol";

/**
 * @title FiatToken
 * @dev ERC20 Token backed by fiat reserves
 */
contract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    string public currency;
    address public masterMinter;
    bool internal initialized;

    /// @dev A mapping that stores the balance and blacklist states for a given address.
    /// The first bit defines whether the address is blacklisted (1 if blacklisted, 0 otherwise).
    /// The last 255 bits define the balance for the address.
    mapping(address =&gt; uint256) internal balanceAndBlacklistStates;
    mapping(address =&gt; mapping(address =&gt; uint256)) internal allowed;
    uint256 internal totalSupply_ = 0;
    mapping(address =&gt; bool) internal minters;
    mapping(address =&gt; uint256) internal minterAllowed;

    event Mint(address indexed minter, address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);
    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);
    event MinterRemoved(address indexed oldMinter);
    event MasterMinterChanged(address indexed newMasterMinter);

    /**
     * @notice Initializes the fiat token contract.
     * @param tokenName       The name of the fiat token.
     * @param tokenSymbol     The symbol of the fiat token.
     * @param tokenCurrency   The fiat currency that the token represents.
     * @param tokenDecimals   The number of decimals that the token uses.
     * @param newMasterMinter The masterMinter address for the fiat token.
     * @param newPauser       The pauser address for the fiat token.
     * @param newBlacklister  The blacklister address for the fiat token.
     * @param newOwner        The owner of the fiat token.
     */
    function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        string memory tokenCurrency,
        uint8 tokenDecimals,
        address newMasterMinter,
        address newPauser,
        address newBlacklister,
        address newOwner
    ) public {
        require(!initialized, "FiatToken: contract is already initialized");
        require(
            newMasterMinter != address(0),
            "FiatToken: new masterMinter is the zero address"
        );
        require(
            newPauser != address(0),
            "FiatToken: new pauser is the zero address"
        );
        require(
            newBlacklister != address(0),
            "FiatToken: new blacklister is the zero address"
        );
        require(
            newOwner != address(0),
            "FiatToken: new owner is the zero address"
        );

        name = tokenName;
        symbol = tokenSymbol;
        currency = tokenCurrency;
        decimals = tokenDecimals;
        masterMinter = newMasterMinter;
        pauser = newPauser;
        blacklister = newBlacklister;
        setOwner(newOwner);
        initialized = true;
    }

    /**
     * @dev Throws if called by any account other than a minter.
     */
    modifier onlyMinters() {
        require(minters[msg.sender], "FiatToken: caller is not a minter");
        _;
    }

    /**
     * @notice Mints fiat tokens to an address.
     * @param _to The address that will receive the minted tokens.
     * @param _amount The amount of tokens to mint. Must be less than or equal
     * to the minterAllowance of the caller.
     * @return True if the operation was successful.
     */
    function mint(address _to, uint256 _amount)
        external
        whenNotPaused
        onlyMinters
        notBlacklisted(msg.sender)
        notBlacklisted(_to)
        returns (bool)
    {
        require(_to != address(0), "FiatToken: mint to the zero address");
        require(_amount &gt; 0, "FiatToken: mint amount not greater than 0");

        uint256 mintingAllowedAmount = minterAllowed[msg.sender];
        require(
            _amount &lt;= mintingAllowedAmount,
            "FiatToken: mint amount exceeds minterAllowance"
        );

        totalSupply_ = totalSupply_.add(_amount);
        _setBalance(_to, _balanceOf(_to).add(_amount));
        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);
        emit Mint(msg.sender, _to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    /**
     * @dev Throws if called by any account other than the masterMinter
     */
    modifier onlyMasterMinter() {
        require(
            msg.sender == masterMinter,
            "FiatToken: caller is not the masterMinter"
        );
        _;
    }

    /**
     * @notice Gets the minter allowance for an account.
     * @param minter The address to check.
     * @return The remaining minter allowance for the account.
     */
    function minterAllowance(address minter) external view returns (uint256) {
        return minterAllowed[minter];
    }

    /**
     * @notice Checks if an account is a minter.
     * @param account The address to check.
     * @return True if the account is a minter, false if the account is not a minter.
     */
    function isMinter(address account) external view returns (bool) {
        return minters[account];
    }

    /**
     * @notice Gets the remaining amount of fiat tokens a spender is allowed to transfer on
     * behalf of the token owner.
     * @param owner   The token owner's address.
     * @param spender The spender's address.
     * @return The remaining allowance.
     */
    function allowance(address owner, address spender)
        external
        override
        view
        returns (uint256)
    {
        return allowed[owner][spender];
    }

    /**
     * @notice Gets the totalSupply of the fiat token.
     * @return The totalSupply of the fiat token.
     */
    function totalSupply() external override view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @notice Gets the fiat token balance of an account.
     * @param account  The address to check.
     * @return balance The fiat token balance of the account.
     */
    function balanceOf(address account)
        external
        override
        view
        returns (uint256)
    {
        return _balanceOf(account);
    }

    /**
     * @notice Sets a fiat token allowance for a spender to spend on behalf of the caller.
     * @param spender The spender's address.
     * @param value   The allowance amount.
     * @return True if the operation was successful.
     */
    function approve(address spender, uint256 value)
        external
        virtual
        override
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(spender)
        returns (bool)
    {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Internal function to set allowance.
     * @param owner     Token owner's address.
     * @param spender   Spender's address.
     * @param value     Allowance amount.
     */
    function _approve(
        address owner,
        address spender,
        uint256 value
    ) internal override {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @notice Transfers tokens from an address to another by spending the caller's allowance.
     * @dev The caller must have some fiat token allowance on the payer's tokens.
     * @param from  Payer's address.
     * @param to    Payee's address.
     * @param value Transfer amount.
     * @return True if the operation was successful.
     */
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
        external
        override
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(from)
        notBlacklisted(to)
        returns (bool)
    {
        require(
            value &lt;= allowed[from][msg.sender],
            "ERC20: transfer amount exceeds allowance"
        );
        _transfer(from, to, value);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        return true;
    }

    /**
     * @notice Transfers tokens from the caller.
     * @param to    Payee's address.
     * @param value Transfer amount.
     * @return True if the operation was successful.
     */
    function transfer(address to, uint256 value)
        external
        override
        whenNotPaused
        notBlacklisted(msg.sender)
        notBlacklisted(to)
        returns (bool)
    {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @dev Internal function to process transfers.
     * @param from  Payer's address.
     * @param to    Payee's address.
     * @param value Transfer amount.
     */
    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(
            value &lt;= _balanceOf(from),
            "ERC20: transfer amount exceeds balance"
        );

        _setBalance(from, _balanceOf(from).sub(value));
        _setBalance(to, _balanceOf(to).add(value));
        emit Transfer(from, to, value);
    }

    /**
     * @notice Adds or updates a new minter with a mint allowance.
     * @param minter The address of the minter.
     * @param minterAllowedAmount The minting amount allowed for the minter.
     * @return True if the operation was successful.
     */
    function configureMinter(address minter, uint256 minterAllowedAmount)
        external
        whenNotPaused
        onlyMasterMinter
        returns (bool)
    {
        minters[minter] = true;
        minterAllowed[minter] = minterAllowedAmount;
        emit MinterConfigured(minter, minterAllowedAmount);
        return true;
    }

    /**
     * @notice Removes a minter.
     * @param minter The address of the minter to remove.
     * @return True if the operation was successful.
     */
    function removeMinter(address minter)
        external
        onlyMasterMinter
        returns (bool)
    {
        minters[minter] = false;
        minterAllowed[minter] = 0;
        emit MinterRemoved(minter);
        return true;
    }

    /**
     * @notice Allows a minter to burn some of its own tokens.
     * @dev The caller must be a minter, must not be blacklisted, and the amount to burn
     * should be less than or equal to the account's balance.
     * @param _amount the amount of tokens to be burned.
     */
    function burn(uint256 _amount)
        external
        whenNotPaused
        onlyMinters
        notBlacklisted(msg.sender)
    {
        uint256 balance = _balanceOf(msg.sender);
        require(_amount &gt; 0, "FiatToken: burn amount not greater than 0");
        require(balance &gt;= _amount, "FiatToken: burn amount exceeds balance");

        totalSupply_ = totalSupply_.sub(_amount);
        _setBalance(msg.sender, balance.sub(_amount));
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
    }

    /**
     * @notice Updates the master minter address.
     * @param _newMasterMinter The address of the new master minter.
     */
    function updateMasterMinter(address _newMasterMinter) external onlyOwner {
        require(
            _newMasterMinter != address(0),
            "FiatToken: new masterMinter is the zero address"
        );
        masterMinter = _newMasterMinter;
        emit MasterMinterChanged(masterMinter);
    }

    /**
     * @inheritdoc Blacklistable
     */
    function _blacklist(address _account) internal override {
        _setBlacklistState(_account, true);
    }

    /**
     * @inheritdoc Blacklistable
     */
    function _unBlacklist(address _account) internal override {
        _setBlacklistState(_account, false);
    }

    /**
     * @dev Helper method that sets the blacklist state of an account.
     * @param _account         The address of the account.
     * @param _shouldBlacklist True if the account should be blacklisted, false if the account should be unblacklisted.
     */
    function _setBlacklistState(address _account, bool _shouldBlacklist)
        internal
        virtual
    {
        _deprecatedBlacklisted[_account] = _shouldBlacklist;
    }

    /**
     * @dev Helper method that sets the balance of an account.
     * @param _account The address of the account.
     * @param _balance The new fiat token balance of the account.
     */
    function _setBalance(address _account, uint256 _balance) internal virtual {
        balanceAndBlacklistStates[_account] = _balance;
    }

    /**
     * @inheritdoc Blacklistable
     */
    function _isBlacklisted(address _account)
        internal
        virtual
        override
        view
        returns (bool)
    {
        return _deprecatedBlacklisted[_account];
    }

    /**
     * @dev Helper method to obtain the balance of an account.
     * @param _account  The address of the account.
     * @return          The fiat token balance of the account.
     */
    function _balanceOf(address _account)
        internal
        virtual
        view
        returns (uint256)
    {
        return balanceAndBlacklistStates[_account];
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1.1/sourcecode/FiatTokenV1_1/FiatTokenV1_1.png" alt="alt text" /></p>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright (c) 2023, Circle Internet Financial, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pragma solidity 0.6.12;

import { FiatTokenV1 } from "../v1/FiatTokenV1.sol";
import { Rescuable } from "./Rescuable.sol";

/**
 * @title FiatTokenV1_1
 * @dev ERC20 Token backed by fiat reserves
 */
contract FiatTokenV1_1 is FiatTokenV1, Rescuable {

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="BlockChain/Ethereum/Solidity/SourceCodeAnalysis/USDC/V1.1/sourcecode/Rescuable/Rescuable.png" alt="alt text" /></p>
<h3 id="rescuable"><a class="header" href="#rescuable">Rescuable</a></h3>
<pre><code class="language-solidity">/**
 * SPDX-License-Identifier: Apache-2.0
 *
 * Copyright (c) 2023, Circle Internet Financial, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

pragma solidity 0.6.12;

import { Ownable } from "../v1/Ownable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

contract Rescuable is Ownable {
    using SafeERC20 for IERC20;

    address private _rescuer;

    event RescuerChanged(address indexed newRescuer);

    /**
     * @notice Returns current rescuer
     * @return Rescuer's address
     */
    function rescuer() external view returns (address) {
        return _rescuer;
    }

    /**
     * @notice Revert if called by any account other than the rescuer.
     */
    modifier onlyRescuer() {
        require(msg.sender == _rescuer, "Rescuable: caller is not the rescuer");
        _;
    }

    /**
     * @notice Rescue ERC20 tokens locked up in this contract.
     * @param tokenContract ERC20 token contract address
     * @param to        Recipient address
     * @param amount    Amount to withdraw
     */
    function rescueERC20(
        IERC20 tokenContract,
        address to,
        uint256 amount
    ) external onlyRescuer {
        tokenContract.safeTransfer(to, amount);
    }

    /**
     * @notice Updates the rescuer address.
     * @param newRescuer The address of the new rescuer.
     */
    function updateRescuer(address newRescuer) external onlyOwner {
        require(
            newRescuer != address(0),
            "Rescuable: new rescuer is the zero address"
        );
        _rescuer = newRescuer;
        emit RescuerChanged(newRescuer);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ignition再次部署合约报错</p>
<p><strong><u>重新部署合约时，由于ignition有记录部署过本合约而拒绝重新部署</u></strong></p>
<pre><code>[ Transaction ] reconciliation failed ⛔

The module contains changes to executed futures:

Transaction#GLDToken:

- From account has been changed from 0x0988258112531ef09ebfbdb5a0b5a537bc4b860c to 0x373d36662619ed994e9778c5be4f7044f005ff9b

Consider modifying your module to remove the inconsistencies with deployed futures.
</code></pre>
<p>解决方法：</p>
<pre><code>npx hardhat ignition wipe deploymentId futureId
</code></pre>
<p>Hardhat官方说明文档</p>
<p><a href="https://hardhat.org/ignition/docs/guides/error-handling#wiping-a-previous-execution">Handling errors | Ethereum development environment for professionals by Nomic Foundation</a></p>
<p>部署环境说明：</p>
<p>Ganache，非公链</p>
<h4 id="补充说明"><a class="header" href="#补充说明"><mark>补充说明</mark></a></h4>
<blockquote>
<p>deploymentId         --目前等同于chainid，命名方式为chain-xxx</p>
<p>futureId                   --对应每个需要部署的合约</p>
</blockquote>
<h5 id="deploymentid"><a class="header" href="#deploymentid">deploymentId</a></h5>
<pre><code class="language-npx">npx hardhat ignition deployments
</code></pre>
<p>效果如下</p>
<p><img src="BlockChain/Hardhat/Hardhat-Ignition/redeploy/./2024-12-06-14-48-16-image.png" alt="" /></p>
<h5 id="futureid"><a class="header" href="#futureid">futureId</a></h5>
<p>官方文档</p>
<pre><code>npx hardhat ignition status deploymentId
</code></pre>
<p>项目中实际命令</p>
<pre><code>npx hardhat ignition status chain-1337
</code></pre>
<p>效果如下</p>
<p><img src="BlockChain/Hardhat/Hardhat-Ignition/redeploy/./2024-12-06-14-53-56-image.png" alt="" /></p>
<h4 id="wipe命令擦除原本部署的合约记录"><a class="header" href="#wipe命令擦除原本部署的合约记录">wipe命令擦除原本部署的合约记录</a></h4>
<p>官方文档</p>
<pre><code>npx hardhat ignition wipe deploymentId futureId
</code></pre>
<p>实际命令</p>
<pre><code>npx hardhat ignition wipe chain-1337 Transaction#GLDToken
</code></pre>
<p>效果如下</p>
<p><img src="BlockChain/Hardhat/Hardhat-Ignition/redeploy/./2024-12-06-15-03-50-image.png" alt="" /></p>
<h4 id="重新部署测试"><a class="header" href="#重新部署测试">重新部署测试</a></h4>
<pre><code>npx hardhat ignition deploy ignition/modules/GLD.js --network ganache
</code></pre>
<p>效果如下</p>
<p><img src="BlockChain/Hardhat/Hardhat-Ignition/redeploy/./2024-12-06-15-07-05-image.png" alt="" /></p>
<p>//注意部署脚本的位置替换为自己脚本的路径</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundry"><a class="header" href="#foundry">Foundry</a></h1>
<blockquote>
<p>一个基础教程引导页面</p>
</blockquote>
<h2 id="入门指南书"><a class="header" href="#入门指南书">入门指南书</a></h2>
<p><a href="https://book.getfoundry.sh/">官网导航</a></p>
<p><a href="https://learnblockchain.cn/docs/foundry/i18n/zh/">中文版-登链社区</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<blockquote>
<p>引用（摘自Rust权威指南）译者序</p>
</blockquote>
<blockquote>
<p>作为系统级语言事实上的标杆，C/C++语言诞生至今已经四十余年了。四十年历史的积累从某种角度上讲亦是四十年的负担。为了开发出运行正确的软件，我们需要投入数年的时间来学会如何避免臭名昭著的漏洞，但即便是最为谨慎的开发者，也无法保证自己的程序万无一失。这些漏洞不仅会导致计算机崩溃，还会带来许多意想不到的安全性问题。特别是随着互联网技术的飞速发展，所有人的私密信息都有可能因为这类安全性问题而赤裸裸地暴露在陌生人的面前。
有些语言，比如C#等，试图使用庞大的运行时系统来解决这一问题，其中最常见的解决方案便是垃圾回收（Garbage Collection）机制。这种机制在保证了内存安全的同时，却在某种程度上剥夺了程序员对底层的控制能力，并往往伴随着性能上的额外损耗。
正是在这样的背景之下，Rust应运而生。
Rust站在了前人的肩膀上，借助于最近几十年的语言研究成果，创造出了所有权与生命周期等崭新的概念。相对于C/C++等传统语言，它具有天生的安全性；换句话说，你无法在安全的Rust代码中执行任何非法的内存操作。相对于C#等带有垃圾回收机制的语言来讲，它遵循了零开销抽象（Zero-Cost Abstraction）规则，并为开发者保留了最大的底层控制能力。
Rust从设计伊始便致力于提供高水准的人体工程学体验。你可以在Rust中看到代数数据类型、卫生宏、迭代器等饱经证明的优秀语言设计，这些刻意的设计能够帮助你自然而然地编写出高效且安全的代码。在语言本身之外，Rust核心开发团队还规划并实现了一系列顶尖的工具链——从集成的包管理器到带有依赖管理的构建工具，再到跨越编辑器的自动补全、类型推导及自动格式化等服务工具。
Rust由开源基金会Mozilla推动开发，它的背后有一个完善且热情的社区。年轻的Rust正在众人合力之下不断进步，许许多多像你我一样的开发者共同决定着Rust的前进方向。你能够在Rust的托管网站GitHub上追踪到最新的源代码及开发进展，甚至是参与到Rust本身的开发之中。</p>
</blockquote>
<h2 id="官方资源"><a class="header" href="#官方资源">官方资源</a></h2>
<p>官网：<a href="https://www.rust-lang.org/learn">rust-lang.org</a>
第三方库：<a href="https://crates.io/">crates.io</a>
std-doc :<a href="https://doc.rust-lang.org/std/">std-doc</a></p>
<h2 id="推荐学习资源个人喜好"><a class="header" href="#推荐学习资源个人喜好">推荐学习资源(个人喜好)</a></h2>
<p>在线:   <a href="https://course.rs/">course.rs</a>
电子书：<a href="https://book.douban.com/subject/35081743/">Rust权威指南</a>
练习： <a href="https://github.com/rust-lang/rustlings">rustlings</a></p>
<h2 id="知名项目"><a class="header" href="#知名项目">知名项目</a></h2>
<ul>
<li>多线程、异步相关：<a href="https://github.com/tokio-rs/tokio">tokio</a></li>
<li>图形界面：<a href="https://github.com/tauri-apps/tauri">tauri</a></li>
<li>远程工具：<a href="https://github.com/rustdesk/rustdesk">rustdesk</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust中基本语句给声明的变量绑定某个值"><a class="header" href="#rust中基本语句给声明的变量绑定某个值">rust中基本语句，给声明的变量绑定某个值</a></h1>
<blockquote>
<p>个人理解 ： rust中变量设定是内存安全的基石之一 1.对于指针概念的隐藏，通过变量声明控制 2.对于指针访问操作的限制：通过变量可修改性的限制</p>
</blockquote>
<ul>
<li>变量重绑定：指已经声明过的变量(指针),重新指向另一片内存空间。此内存空间存储的可以是另一种类型的变量。<strong>理解部分:变量可不可变，指的是值，不是指针本身</strong></li>
<li>赋值与绑定的区别：赋值为修改已经声明的变量的值</li>
<li>关键字 <code>let</code>  用于声明变量绑定</li>
</ul>
<h2 id="不可变变量"><a class="header" href="#不可变变量">不可变变量</a></h2>
<ul>
<li>不可变变量：指值在操作过程中不可修改，可理解为C、C++语言中 此变量声明后作为一个指针，指针指向的内存地址数据为只读</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let var1 = 1; //声明并绑定不可变变量
    println!("{}",var1);
    let var1 = 2;//不可变变量重绑定
    println!("{}",var1);
    //var1 = 3; //此代码将报错，将变量赋值给不可变变量
    
}</code></pre></pre>
<h3 id="错误示例"><a class="header" href="#错误示例">错误示例</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main(){
  let var1 = 1; //声明并绑定不可变变量
  println!("{}",var1);
  var1 = 3; //此代码将报错，将变量赋值给不可变变量
  }
</code></pre></pre>
<h2 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h2>
<ul>
<li>可变变量：指值在操作过程中可以修改，可以理解为指针指向的数据可以修改！由于rust变量类型限制，仅能赋值同类型变量。</li>
<li>关键字 <code>mut</code> 用于声明变量可变，不可变则无此声明</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut var2 = 1;//声明并绑定可变变量
    println!("{}",var2);
    var2 = 2; //此代码正确，可变变量可赋值
    println!("{}",var2);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust库中默认内置的变量"><a class="header" href="#rust库中默认内置的变量">rust库中默认内置的变量</a></h1>
<hr />
<h2 id="一标量类型scalar-types"><a class="header" href="#一标量类型scalar-types">一、标量类型（Scalar Types）</a></h2>
<h2 id="1-整数类型integer"><a class="header" href="#1-整数类型integer">1. 整数类型（Integer）</a></h2>
<p>Rust 的整数类型根据<strong>符号</strong>和<strong>位宽</strong>分类，命名格式为 <code>[u|i][位数]</code>：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>位数</th><th>范围</th><th>示例值</th><th>典型场景</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>8</td><td>-128 ~ 127</td><td><code>-5i8</code></td><td>小范围有符号整数</td></tr>
<tr><td><code>u8</code></td><td>8</td><td>0 ~ 255</td><td><code>255u8</code></td><td>字节处理、颜色值</td></tr>
<tr><td><code>i16</code></td><td>16</td><td>-32,768 ~ 32,767</td><td><code>30000i16</code></td><td>中等范围有符号整数</td></tr>
<tr><td><code>u16</code></td><td>16</td><td>0 ~ 65,535</td><td><code>65535u16</code></td><td>Unicode 字符码点（如 <code>'\u{2764}'</code>）</td></tr>
<tr><td><code>i32</code></td><td>32</td><td>-2,147,483,648 ~ 2,147,483,647</td><td><code>42</code>（默认推断）</td><td>通用整数，性能最佳</td></tr>
<tr><td><code>u32</code></td><td>32</td><td>0 ~ 4,294,967,295</td><td><code>1_000_000u32</code></td><td>大范围无符号计数</td></tr>
<tr><td><code>i64</code></td><td>64</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td><td><code>-9_223_372_036i64</code></td><td>时间戳、大数值计算</td></tr>
<tr><td><code>u64</code></td><td>64</td><td>0 ~ 18,446,744,073,709,551,615</td><td><code>18_446_744u64</code></td><td>ID 生成、超大计数</td></tr>
<tr><td><code>isize</code></td><td>平台相关（通常 32/64 位）</td><td>与指针大小相同</td><td><code>-10isize</code></td><td>集合索引、内存偏移量</td></tr>
<tr><td><code>usize</code></td><td>平台相关（通常 32/64 位）</td><td>与指针大小相同</td><td><code>0usize</code></td><td>集合长度、内存地址</td></tr>
</tbody></table>
</div>
<p><strong>关键特性</strong>：</p>
<ul>
<li><strong>默认类型</strong>：未标注时，整数字面量默认推断为 <code>i32</code>。</li>
<li><strong>进制表示</strong>：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let decimal = 98_222;      // 十进制：98222
let hex = 0xff;            // 十六进制：255
let octal = 0o77;          // 八进制：63
let binary = 0b1111_0000;  // 二进制：240
let byte = b'A';           // u8 类型字节：65
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>溢出处理</strong>：Debug 模式下溢出会 panic，Release 模式下自动按补码循环（需显式处理用 <code>Wrapping</code> 类型）。</li>
</ul>
<hr />
<h2 id="2-浮点类型floating-point"><a class="header" href="#2-浮点类型floating-point">2. 浮点类型（Floating-Point）</a></h2>
<p>Rust 提供两种精度浮点数，遵循 IEEE-754 标准：</p>
<p>关于浮点类型是一种以<strong>表达式</strong>形式存储在内存中的变量</p>
<p>图片来源 ：csapp + 个人学习记录
<img src="Rust/Basic/./img/1742208954410.jpg" alt="alt text" />
<img src="Rust/Basic/./img/1742208954417.jpg" alt="alt text" /></p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>位数</th><th>精度</th><th>范围</th><th>示例值</th><th>场景</th></tr></thead><tbody>
<tr><td><code>f32</code></td><td>32</td><td>6-7 位小数</td><td>±3.4×10³⁸ ~ ±1.7×10³⁸</td><td><code>3.14f32</code></td><td>图形计算、嵌入式</td></tr>
<tr><td><code>f64</code></td><td>64</td><td>15-17 位小数</td><td>±1.7×10³⁰⁸ ~ ±1.1×10³⁰⁸</td><td><code>2.718</code>（默认）</td><td>科学计算、通用</td></tr>
</tbody></table>
</div>
<p><strong>重要特性</strong>：</p>
<ul>
<li><strong>默认类型</strong>：未标注时，浮点字面量默认推断为 <code>f64</code>（因现代 CPU 高效支持）。</li>
<li><strong>数值运算</strong>：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 5.0 + 10.0;     // f64
let difference = 95.5 - 4.3;
let product = 4.0 * 30.0;
let quotient = 56.7 / 32.2;
let remainder = 43.0 % 5.0;
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>陷阱</strong>：浮点数存在精度误差，<strong>避免直接判等</strong>：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ 错误写法
assert!(0.1 + 0.2 == 0.3);

// ✅ 正确做法
let tolerance = 1e-10;
assert!((0.1 + 0.2 - 0.3).abs() &lt; tolerance);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<hr />
<h2 id="3-布尔类型boolean"><a class="header" href="#3-布尔类型boolean">3. 布尔类型（Boolean）</a></h2>
<ul>
<li><strong>类型名</strong>：<code>bool</code></li>
<li><strong>值域</strong>：<code>true</code> 或 <code>false</code></li>
<li><strong>内存占用</strong>：1 字节</li>
<li><strong>使用场景</strong>：条件判断、逻辑运算
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_rust_cool = true;
let is_heavy: bool = 10 &gt; 5;  // 自动推断为 true
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<hr />
<h2 id="4-字符类型character"><a class="header" href="#4-字符类型character">4. 字符类型（Character）</a></h2>
<ul>
<li><strong>类型名</strong>：<code>char</code></li>
<li><strong>内存占用</strong>：4 字节（存储 Unicode 标量值）</li>
<li><strong>值域</strong>：U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF</li>
<li><strong>表示方式</strong>：单引号，支持 Unicode 转义：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = 'z';
let emoji = '🚀';            // 直接输入 Unicode
let heart = '\u{2764}';     // Unicode 转义：❤
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<hr />
<h2 id="二复合类型compound-types"><a class="header" href="#二复合类型compound-types">二、复合类型（Compound Types）</a></h2>
<h2 id="1-元组tuple"><a class="header" href="#1-元组tuple">1. 元组（Tuple）</a></h2>
<ul>
<li><strong>定义</strong>：固定长度、可包含不同类型的集合。</li>
<li><strong>内存布局</strong>：元素紧密排列，无额外开销。</li>
<li><strong>示例</strong>：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup: (i32, f64, bool) = (500, 6.4, true);  // 显式类型标注
let (x, y, z) = tup;                            // 解构赋值
let first = tup.0;                              // 索引访问
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>空元组</strong>：<code>()</code> 表示“无返回值”，是函数的默认返回类型。</li>
</ul>
<hr />
<h2 id="2-数组array"><a class="header" href="#2-数组array">2. 数组（Array）</a></h2>
<ul>
<li><strong>定义</strong>：固定长度、相同类型的集合，栈上分配。</li>
<li><strong>适用场景</strong>：已知元素数量的数据集（如月份名称）。</li>
<li><strong>示例</strong>：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["Jan", "Feb", "Mar"];         // 类型推断为 [&amp;str; 3]
let arr: [i32; 5] = [1, 2, 3, 4, 5];       // 显式标注
let zeros = [0; 10];                        // 初始化 10 个 0：[0, 0, ..., 0]
let first = arr[0];                         // 索引访问（编译时检查越界）
<span class="boring">}</span></code></pre></pre>
</li>
<li><strong>越界访问</strong>：运行时 panic（如 <code>arr[5]</code>）。</li>
</ul>
<hr />
<h2 id="三类型转换与处理"><a class="header" href="#三类型转换与处理">三、类型转换与处理</a></h2>
<h2 id="1-显式类型转换as"><a class="header" href="#1-显式类型转换as">1. 显式类型转换（<code>as</code>）</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1000i32;
let y = x as u64;     // 安全转换
let z = x as u8;      // 可能丢失数据（1000 → 232）
<span class="boring">}</span></code></pre></pre>
<h2 id="2-处理不同类型运算"><a class="header" href="#2-处理不同类型运算">2. 处理不同类型运算</a></h2>
<p>需手动统一类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10i32;
let b = 100u32;
let sum = a as i64 + b as i64;  // 统一为 i64 避免溢出
<span class="boring">}</span></code></pre></pre>
<h2 id="3-类型推断与标注"><a class="header" href="#3-类型推断与标注">3. 类型推断与标注</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;          // 默认推断为 i32
let y: u8 = 10;      // 显式标注为 u8
let z = x + y;       // ❌ 错误：类型不匹配
let z = x + y as i32; // ✅ 正确
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="四最佳实践与常见问题"><a class="header" href="#四最佳实践与常见问题">四、最佳实践与常见问题</a></h2>
<h2 id="1-如何选择整数类型"><a class="header" href="#1-如何选择整数类型">1. 如何选择整数类型？</a></h2>
<ul>
<li><strong>通用场景</strong>：优先使用 <code>i32</code>（性能最优）。</li>
<li><strong>内存敏感</strong>：<code>u8</code>、<code>i16</code>（如网络协议）。</li>
<li><strong>大集合索引</strong>：<code>usize</code>（与平台指针同宽）。</li>
</ul>
<h2 id="2-为什么浮点数比较需要特殊处理"><a class="header" href="#2-为什么浮点数比较需要特殊处理">2. 为什么浮点数比较需要特殊处理？</a></h2>
<ul>
<li>浮点运算存在精度损失，直接判等可能失败。</li>
<li>使用误差范围（epsilon）或专用库（如 <code>approx</code>）。</li>
</ul>
<h2 id="3-何时使用数组-vs-向量vect"><a class="header" href="#3-何时使用数组-vs-向量vect">3. 何时使用数组 vs 向量（<code>Vec&lt;T&gt;</code>）？</a></h2>
<ul>
<li><strong>数组</strong>：长度固定、栈分配（高效）。</li>
<li><strong>向量</strong>：动态长度、堆分配（灵活）。</li>
</ul>
<hr />
<h2 id="五代码示例"><a class="header" href="#五代码示例">五、代码示例</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 整数操作
    let decimal = 98_222;             // i32
    let hex = 0xff;                   // i32
    let byte = b'A';                  // u8
    let max_u32 = u32::MAX;           // 4,294,967,295
    
    // 浮点运算
    let x = 2.0;                      // f64
    let y: f32 = 3.0;                 // f32
    let result = x + (y as f64);      // 统一类型
    
    // 布尔逻辑
    let is_greater = 10 &gt; 5;          // true
    
    // 字符与Unicode
    let emoji = '🚀';
    let heart = '\u{2764}';
    
    // 元组和数组
    let tup = (500, 6.4, true);
    let arr = [1, 2, 3, 4, 5];
    let first_element = arr[0];
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过泛型和特征实现不同结构体实现相同效果"><a class="header" href="#通过泛型和特征实现不同结构体实现相同效果">通过泛型和特征实现不同结构体实现相同效果</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::fmt::format;

#[derive(Debug)]
pub struct Teacher {
    age: i32,
    name: String,
    skill: String,
}
pub struct Student {
    age: i32,
    name: String,
    class: u32,
}
pub trait TellInfo {
    fn Sayage(&amp;self);
    fn SelfIntroduction(&amp;self) -&gt; String;
    
}

impl TellInfo for Teacher {
    fn Sayage(&amp;self) {
        println!("Teacher {}'s age is {}", self.name, self.age);
    }
    fn SelfIntroduction(&amp;self) -&gt; String {
        let brief_intro = format!(
            "As a teacher,my name is {},i'm {} years old and my skill includes {}",
            self.name, self.age, self.skill
        );
        brief_intro
    }
}

impl TellInfo for Student {
    fn Sayage(&amp;self) {
        println!("Student {}'s age is {}", self.name, self.age);
    }
    fn SelfIntroduction(&amp;self) -&gt; String {
        let brief_intro = format!(
            "As a student,my name is {},i'm {} years old and my come from NO.{} class",
            self.name, self.age, self.class
        );
        brief_intro
    }
}

 fn StageSpeech(T: &amp;impl TellInfo) { //引入特征变量
        let Info = T.SelfIntroduction();
        println!("{}", &amp;Info);
    }

fn main() {
   

    let Teacher1 = Teacher {
        age: 33,
        name: "Tom".to_string(),
        skill: "Math/english/phyisc".to_string(),
    };
    let Student1 = Student {
        age: 14,
        name: "charles".to_string(),
        class: 3,
    };
    StageSpeech(&amp;Teacher1);
    StageSpeech(&amp;Student1);
}</code></pre></pre>
<ul>
<li>特征类似于java等类语言中的接口，用于给自定义类型或者常见类型变量实现指定的方法</li>
<li>常见声明如下 <code>pub trait trait1 { fn a(&amp;self)-&gt;Self{};}</code>,常用于声明和定义方法和函数：方法和函数的区别在于 方法中引用变量自身作为参数传入 ，而函数不依赖</li>
<li>特征变量：从各类变量中抽象出来，仅作为有某一特定特征的变量 调用方式:1. 在函数声明中直接声明，例 <code>fn a(T:&amp;impl Display)</code>  2. Box<dyn Display> 使用智能指针封装并调用。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
